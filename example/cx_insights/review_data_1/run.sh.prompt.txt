claude-3-5-sonnet-20240620

# Example Project
This is the example project which has 3 main files "server.py", "index.html" and "run.sh".
Here are their contents:

## server.py
```python

import sqlite3
import threading
import time
import traceback
import csv
import io

from flask import Flask, jsonify, request, send_from_directory, send_file
from flask_cors import CORS
from flask_socketio import SocketIO

from finae import web_search_agent, web_scraper_agent

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

DATABASE = 'crm.db'
ENTRIES_PER_PAGE = 10

# Virtual Agent Configuration
AGENT_NAME = "Web Search & Scraper Agent"
AGENT_AVATAR = "https://robohash.org/WebSearchScraperAgent.png?size=100x100&set=set3"
AGENT_PROMPT = '''Advanced competitor searcher and web scraper.

Search internet to find all information of competitor company "wordware.ai". 
Then scrape the found URLs for more detailed information.
'''

# Data generation control
data_generation_active = False
data_generation_thread = None


def get_db_connection():
    conn = sqlite3.connect(DATABASE)
    conn.row_factory = sqlite3.Row
    return conn


def init_db():
    with get_db_connection() as conn:
        conn.execute('''CREATE TABLE IF NOT EXISTS crm_entries
                        (id INTEGER PRIMARY KEY AUTOINCREMENT,
                         title TEXT,
                         link TEXT,
                         content TEXT,
                         webpage_content TEXT,
                         scrape_status TEXT,
                         timestamp DATETIME DEFAULT CURRENT_TIMESTAMP)''')
        conn.commit()


def produce_data_point(data_entry: dict):
    try:
        with get_db_connection() as conn:
            c = conn.cursor()

            title = data_entry.get('title', '')
            link = data_entry.get('link', '')
            content = data_entry.get('content', '')
            webpage_content = ''
            scrape_status = 'pending'

            c.execute("INSERT INTO crm_entries (title, link, content, webpage_content, scrape_status) VALUES (?, ?, ?, ?, ?)",
                      (title, link, content, webpage_content, scrape_status))
            conn.commit()

            new_entry = c.execute("SELECT * FROM crm_entries WHERE id = last_insert_rowid()").fetchone()

        socketio.emit('new_entry', dict(new_entry))
        print(f"New entry added and emitted: {dict(new_entry)}")

        # Start scraping the URL in a separate thread
        threading.Thread(target=scrape_url, args=(link,)).start()

    except Exception as e:
        print(f"Error in produce_data_point: {str(e)}")
        traceback.print_exc()


def ingest_data():
    global data_generation_active
    while data_generation_active:
        web_search_agent(AGENT_PROMPT, produce_data_point)
        time.sleep(10)


def scrape_url(url):
    def scrape_producer(data):
        try:
            with get_db_connection() as conn:
                c = conn.cursor()
                c.execute("UPDATE crm_entries SET webpage_content = ?, scrape_status = ? WHERE link = ?",
                          (data['webpage_content'], 'scraped', data['url']))
                conn.commit()
            
            socketio.emit('entry_updated', {'url': url, 'webpage_content': data['webpage_content'], 'scrape_status': 'scraped'})
        except Exception as e:
            print(f"Error in scrape_producer: {str(e)}")
            update_scrape_status(url, 'failed')

    try:
        web_scraper_agent(url, scrape_producer)
    except Exception as e:
        print(f"Error in scrape_url: {str(e)}")
        update_scrape_status(url, 'failed')


def update_scrape_status(url, status):
    try:
        with get_db_connection() as conn:
            c = conn.cursor()
            c.execute("UPDATE crm_entries SET scrape_status = ? WHERE link = ?", (status, url))
            conn.commit()
        
        socketio.emit('entry_updated', {'url': url, 'scrape_status': status})
    except Exception as e:
        print(f"Error in update_scrape_status: {str(e)}")


@app.route('/')
def index():
    return send_from_directory('.', 'index.html')


@app.route('/api/entries', methods=['GET'])
def get_entries():
    page = request.args.get('page', 1, type=int)
    offset = (page - 1) * ENTRIES_PER_PAGE

    with get_db_connection() as conn:
        total_entries = conn.execute("SELECT COUNT(*) FROM crm_entries").fetchone()[0]
        entries = conn.execute("SELECT * FROM crm_entries ORDER BY timestamp DESC LIMIT ? OFFSET ?",
                               (ENTRIES_PER_PAGE, offset)).fetchall()

    return jsonify({
        'entries': [dict(entry) for entry in entries],
        'total_entries': total_entries,
        'total_pages': (total_entries + ENTRIES_PER_PAGE - 1) // ENTRIES_PER_PAGE
    })


@app.route('/api/entries', methods=['POST'])
def add_entry():
    data = request.json
    if not data or 'title' not in data or 'link' not in data or 'content' not in data:
        return jsonify({'error': 'Invalid data'}), 400

    with get_db_connection() as conn:
        c = conn.cursor()
        c.execute("INSERT INTO crm_entries (title, link, content, scrape_status) VALUES (?, ?, ?, ?)",
                  (data['title'], data['link'], data['content'], 'pending'))
        conn.commit()
        new_id = c.lastrowid

        new_entry = c.execute("SELECT * FROM crm_entries WHERE id = ?", (new_id,)).fetchone()

    socketio.emit('new_entry', dict(new_entry))

    # Start scraping the URL in a separate thread
    threading.Thread(target=scrape_url, args=(data['link'],)).start()

    return jsonify({'id': new_id, 'message': 'Entry added successfully'}), 201


@app.route('/api/agent', methods=['GET'])
def get_agent_info():
    return jsonify({
        'name': AGENT_NAME,
        'avatar': AGENT_AVATAR
    })


@app.route('/api/data_generation/start', methods=['POST'])
def start_data_generation():
    global data_generation_active, data_generation_thread
    if not data_generation_active:
        data_generation_active = True
        data_generation_thread = threading.Thread(target=ingest_data)
        data_generation_thread.start()
        return jsonify({'message': 'Data generation started'}), 200
    return jsonify({'message': 'Data generation already running'}), 200


@app.route('/api/data_generation/stop', methods=['POST'])
def stop_data_generation():
    global data_generation_active, data_generation_thread
    if data_generation_active:
        data_generation_active = False
        if data_generation_thread:
            data_generation_thread.join()
        return jsonify({'message': 'Data generation stopped'}), 200
    return jsonify({'message': 'Data generation not running'}), 200


@app.route('/api/data_generation/status', methods=['GET'])
def get_data_generation_status():
    global data_generation_active
    return jsonify({'active': data_generation_active})


@app.route('/api/export_csv', methods=['GET'])
def export_csv():
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM crm_entries ORDER BY timestamp DESC")
        rows = cursor.fetchall()

    output = io.StringIO()
    writer = csv.writer(output)
    
    writer.writerow(['id', 'title', 'link', 'content', 'webpage_content', 'scrape_status', 'timestamp'])
    
    for row in rows:
        writer.writerow(row)

    output.seek(0)
    return send_file(
        io.BytesIO(output.getvalue().encode('utf-8')),
        mimetype='text/csv',
        as_attachment=True,
        download_name='crm_entries.csv'
    )


@socketio.on('connect')
def handle_connect():
    print('Client connected')


@socketio.on('disconnect')
def handle_disconnect():
    print('Client disconnected')


if __name__ == '__main__':
    init_db()
    port = 8593
    print(f"Server running on port {port}")
    socketio.run(app, host='0.0.0.0', port=port, debug=True)

```

## index.html
```html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Search & Scraper Agent</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .animate-bounce {
            animation: bounce 2s infinite;
        }
        .table-container {
            max-height: 70vh;
            overflow-y: auto;
        }
        #crmTable th, #crmTable td {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }
        #crmTable td.expanded {
            white-space: normal;
            max-width: none;
        }
        .expand-btn {
            cursor: pointer;
            user-select: none;
            transition: transform 0.3s ease;
        }
        .expand-btn.expanded {
            transform: rotate(180deg);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <header class="bg-gray-600 text-white shadow-lg">
        <div class="container mx-auto px-4 py-6 flex justify-between items-center">
            <h1 class="text-3xl font-bold">Web research AI agent</h1>
            <div class="flex items-center">
                <button id="startBtn" class="bg-blue-500 text-white px-4 py-2 rounded-lg shadow hover:bg-green-600 transition duration-300 ease-in-out mr-2">
                    Start
                </button>
                <button id="stopBtn" class="bg-orange-500 text-white px-4 py-2 rounded-lg shadow hover:bg-red-600 transition duration-300 ease-in-out mr-2">
                    Pause
                </button>
                <span id="statusIndicator" class="mr-2">⚪</span>
                <button id="refreshBtn" class="bg-white text-indigo-600 px-4 py-2 rounded-lg shadow hover:bg-indigo-100 transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 mr-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-1" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
                    </svg>
                    Refresh
                </button>
                <button id="exportCsvBtn" class="bg-yellow-500 text-white px-4 py-2 rounded-lg shadow hover:bg-yellow-600 transition duration-300 ease-in-out">
                    Export CSV
                </button>
            </div>
        </div>
    </header>
    <main class="container mx-auto px-4 py-8">
        <div id="newEntriesAlert" class="hidden bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4" role="alert">
            <p class="font-bold">New entries available!</p>
            <p>Click the button below to load the latest entries.</p>
            <button id="loadNewEntriesBtn" class="mt-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                Load New Entries
            </button>
        </div>
        <div class="bg-white rounded-lg shadow-md overflow-hidden">
            <div class="table-container">
                <table id="crmTable" class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Expand</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ID</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Title</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Link</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Summary</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Content</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Scrape Status</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Timestamp</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200">
                        <!-- Table rows will be dynamically inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
        <div class="mt-4 flex justify-between items-center">
            <div>
                <span id="pageInfo" class="text-sm text-gray-600"></span>
            </div>
            <div>
                <button id="prevBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg shadow hover:bg-indigo-700 transition duration-300 ease-in-out mr-2">Previous</button>
                <button id="nextBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg shadow hover:bg-indigo-700 transition duration-300 ease-in-out">Next</button>
            </div>
        </div>
        <div id="loadingSpinner" class="hidden fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
            <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-indigo-500"></div>
        </div>
    </main>
    <script>
        const API_URL = `http://${window.location.hostname}:8593/api`;
        const loadingSpinner = document.getElementById('loadingSpinner');
        const pageInfo = document.getElementById('pageInfo');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusIndicator = document.getElementById('statusIndicator');
        const newEntriesAlert = document.getElementById('newEntriesAlert');
        const loadNewEntriesBtn = document.getElementById('loadNewEntriesBtn');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        let currentPage = 1;
        let totalPages = 1;
        let totalEntries = 0;
        let newEntriesCount = 0;

        const socket = io(`http://${window.location.hostname}:8593`);

        socket.on('connect', () => {
            console.log('Connected to WebSocket');
        });

        socket.on('new_entry', (entry) => {
            console.log('New entry received:', entry);
            if (currentPage === 1) {
                prependEntry(entry);
            } else {
                newEntriesCount++;
                showNewEntriesAlert();
            }
            updateTotalEntries(totalEntries + 1);
        });

        socket.on('entry_updated', (data) => {
            console.log('Entry updated:', data);
            updateEntryData(data);
        });

        async function fetchEntries(page = 1) {
            try {
                loadingSpinner.classList.remove('hidden');
                const response = await fetch(`${API_URL}/entries?page=${page}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                updateTable(data.entries);
                updatePagination(page, data.total_pages, data.total_entries);
            } catch (error) {
                console.error('Error fetching entries:', error);
            } finally {
                loadingSpinner.classList.add('hidden');
            }
        }

        function updateTable(entries) {
            const tableBody = document.querySelector('#crmTable tbody');
            tableBody.innerHTML = '';

            entries.forEach(entry => {
                const row = createTableRow(entry);
                tableBody.appendChild(row);
            });
        }

        function createTableRow(entry) {
            const row = document.createElement('tr');
            row.className = 'hover:bg-gray-50 transition duration-150 ease-in-out';
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                    <svg class="expand-btn w-5 h-5 text-gray-500 hover:text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${escapeHtml(entry.id)}</td>
                <td class="px-6 py-4 text-sm font-medium text-gray-900">${escapeHtml(entry.title)}</td>
                <td class="px-6 py-4 text-sm text-indigo-600 hover:text-indigo-900">
                    <a href="${escapeHtml(entry.link)}" target="_blank" class="hover:underline">${escapeHtml(entry.link)}</a>
                </td>
                <td class="px-6 py-4 text-sm text-gray-500">${escapeHtml(entry.content)}</td>
                <td class="px-6 py-4 text-sm text-gray-500">${escapeHtml(entry.webpage_content || '')}</td>
                <td class="px-6 py-4 text-sm text-gray-500">${getScrapeStatusBadge(entry.scrape_status)}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${new Date(entry.timestamp).toLocaleString()}</td>
            `;

            const expandBtn = row.querySelector('.expand-btn');
            expandBtn.addEventListener('click', () => {
                const cells = row.querySelectorAll('td:not(:first-child)');
                cells.forEach(cell => cell.classList.toggle('expanded'));
                expandBtn.classList.toggle('expanded');
            });

            return row;
        }

        function getScrapeStatusBadge(status) {
            const statusColors = {
                'pending': 'bg-yellow-100 text-yellow-800',
                'scraped': 'bg-green-100 text-green-800',
                'failed': 'bg-red-100 text-red-800'
            };
            const color = statusColors[status] || 'bg-gray-100 text-gray-800';
            return `<span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${color}">${status}</span>`;
        }

        function prependEntry(entry) {
            const tableBody = document.querySelector('#crmTable tbody');
            const row = createTableRow(entry);
            tableBody.insertBefore(row, tableBody.firstChild);
            
            // Remove the last row if we have more than 10 entries
            if (tableBody.children.length > 10) {
                tableBody.removeChild(tableBody.lastChild);
            }
        }

        function updateEntryData(data) {
            const tableBody = document.querySelector('#crmTable tbody');
            const rows = tableBody.querySelectorAll('tr');
            for (const row of rows) {
                const linkCell = row.querySelector('td:nth-child(4)');
                if (linkCell && linkCell.textContent.trim() === data.url) {
                    if (data.webpage_content) {
                        const webpageContentCell = row.querySelector('td:nth-child(6)');
                        if (webpageContentCell) {
                            webpageContentCell.textContent = data.webpage_content;
                        }
                    }
                    if (data.scrape_status) {
                        const scrapeStatusCell = row.querySelector('td:nth-child(7)');
                        if (scrapeStatusCell) {
                            scrapeStatusCell.innerHTML = getScrapeStatusBadge(data.scrape_status);
                        }
                    }
                    break;
                }
            }
        }

        function updatePagination(page, total, entries) {
            currentPage = page;
            totalPages = total;
            totalEntries = entries;
            pageInfo.textContent = `Page ${page} of ${total} (${entries} total entries)`;
            prevBtn.disabled = page === 1;
            nextBtn.disabled = page === total;
        }

        function updateTotalEntries(newTotal) {
            totalEntries = newTotal;
            totalPages = Math.ceil(totalEntries / 10);
            pageInfo.textContent = `Page ${currentPage} of ${totalPages} (${totalEntries} total entries)`;
            nextBtn.disabled = currentPage === totalPages;
        }

        function showNewEntriesAlert() {
            newEntriesAlert.classList.remove('hidden');
            loadNewEntriesBtn.textContent = `Load ${newEntriesCount} New Entries`;
        }

        function hideNewEntriesAlert() {
            newEntriesAlert.classList.add('hidden');
            newEntriesCount = 0;
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe === 'number') {
                return unsafe.toString();
            }
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        async function startDataGeneration() {
            try {
                const response = await fetch(`${API_URL}/data_generation/start`, { method: 'POST' });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                updateDataGenerationStatus(true);
            } catch (error) {
                console.error('Error starting data generation:', error);
            }
        }

        async function stopDataGeneration() {
            try {
                const response = await fetch(`${API_URL}/data_generation/stop`, { method: 'POST' });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                updateDataGenerationStatus(false);
            } catch (error) {
                console.error('Error stopping data generation:', error);
            }
        }

        async function checkDataGenerationStatus() {
            try {
                const response = await fetch(`${API_URL}/data_generation/status`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                updateDataGenerationStatus(data.active);
            } catch (error) {
                console.error('Error checking data generation status:', error);
            }
        }

        function updateDataGenerationStatus(active) {
            if (active) {
                statusIndicator.textContent = '🟢';
                statusIndicator.title = 'Data generation is active';
            } else {
                statusIndicator.textContent = '🔴';
                statusIndicator.title = 'Data generation is inactive';
            }
        }

        async function exportCsv() {
            try {
                const response = await fetch(`${API_URL}/export_csv`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'crm_entries.csv';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error exporting CSV:', error);
            }
        }

        prevBtn.addEventListener('click', () => {
            if (currentPage > 1) {
                fetchEntries(currentPage - 1);
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentPage < totalPages) {
                fetchEntries(currentPage + 1);
            }
        });

        document.getElementById('refreshBtn').addEventListener('click', () => fetchEntries(currentPage));
        startBtn.addEventListener('click', startDataGeneration);
        stopBtn.addEventListener('click', stopDataGeneration);
        exportCsvBtn.addEventListener('click', exportCsv);

        loadNewEntriesBtn.addEventListener('click', () => {
            fetchEntries(1);
            hideNewEntriesAlert();
        });

        // Initial setup
        fetchEntries();
        checkDataGenerationStatus();

        // Periodically check data generation status
        setInterval(checkDataGenerationStatus, 5000);
    </script>
</body>
</html>

```

## run.sh
```bash

#!/bin/bash

# Exit immediately if a command exits with a non-zero status
set -e

# Create a virtual environment if it doesn't exist
if [ ! -d "venv" ]; then
    echo "Creating virtual environment..."
    python3 -m venv venv
fi

# Activate the virtual environment
source venv/bin/activate

# Upgrade pip
pip install --upgrade pip

# Install required libraries
echo "Installing required libraries..."
pip install Flask flask-cors flask-socketio

# Start the server
echo "Starting the Web Search & Scraper Agent server..."
python server.py

# Keep the script running
while true; do
    echo "Web Search & Scraper Agent server is running on port 8593. Press Ctrl+C to stop."
    sleep 60
done

```

# Objective
Modify and re-generate these files based on new <FEATURE_REQUEST></FEATURE_REQUEST> statements.

# Output
1. Output new "server.py" source code in <SERVER_PYTHON_CODE></SERVER_PYTHON_CODE> block.
2. Output new "index.html" source code in <INDEX_HTML_CODE></INDEX_HTML_CODE> block.
3. Output new "run.sh" source code in <RUN_BASH_CODE></RUN_BASH_CODE> block.

Only output one of them in each conversation round, based on user query.


=== 0: user ===
<FEATURE_REQUEST>
Similar to the example.
But change the data to be "customer review", including columns "Name", "Data", "Platform", "Review Content".
Remove Agent, but add a button "Generate Random Review" to generate one row of mock data.
</FEATURE_REQUEST>

Generate new "server.py" first. Re-assign a new PORT, to "0.0.0.0:9722".

=== 1: assistant ===
Certainly! I'll modify the "server.py" file based on your feature request. Here's the updated "server.py" with the changes you've requested:

<SERVER_PYTHON_CODE>
import sqlite3
import threading
import time
import traceback
import csv
import io
import random

from flask import Flask, jsonify, request, send_from_directory, send_file
from flask_cors import CORS
from flask_socketio import SocketIO

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

DATABASE = 'customer_reviews.db'
ENTRIES_PER_PAGE = 10

# Data generation control
data_generation_active = False
data_generation_thread = None

def get_db_connection():
    conn = sqlite3.connect(DATABASE)
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    with get_db_connection() as conn:
        conn.execute('''CREATE TABLE IF NOT EXISTS customer_reviews
                        (id INTEGER PRIMARY KEY AUTOINCREMENT,
                         name TEXT,
                         date TEXT,
                         platform TEXT,
                         review_content TEXT,
                         timestamp DATETIME DEFAULT CURRENT_TIMESTAMP)''')
        conn.commit()

def generate_random_review():
    names = ["John Doe", "Jane Smith", "Mike Johnson", "Emily Brown", "David Lee"]
    platforms = ["Amazon", "Google", "Yelp", "Facebook", "TripAdvisor"]
    
    review = {
        "name": random.choice(names),
        "date": time.strftime("%Y-%m-%d"),
        "platform": random.choice(platforms),
        "review_content": f"This is a randomly generated review. The service was {'great' if random.random() > 0.5 else 'okay'}. I {'would' if random.random() > 0.7 else 'might'} recommend it to others."
    }
    
    return review

@app.route('/')
def index():
    return send_from_directory('.', 'index.html')

@app.route('/api/reviews', methods=['GET'])
def get_reviews():
    page = request.args.get('page', 1, type=int)
    offset = (page - 1) * ENTRIES_PER_PAGE

    with get_db_connection() as conn:
        total_reviews = conn.execute("SELECT COUNT(*) FROM customer_reviews").fetchone()[0]
        reviews = conn.execute("SELECT * FROM customer_reviews ORDER BY timestamp DESC LIMIT ? OFFSET ?",
                               (ENTRIES_PER_PAGE, offset)).fetchall()

    return jsonify({
        'reviews': [dict(review) for review in reviews],
        'total_reviews': total_reviews,
        'total_pages': (total_reviews + ENTRIES_PER_PAGE - 1) // ENTRIES_PER_PAGE
    })

@app.route('/api/reviews', methods=['POST'])
def add_review():
    data = request.json
    if not data or 'name' not in data or 'date' not in data or 'platform' not in data or 'review_content' not in data:
        return jsonify({'error': 'Invalid data'}), 400

    with get_db_connection() as conn:
        c = conn.cursor()
        c.execute("INSERT INTO customer_reviews (name, date, platform, review_content) VALUES (?, ?, ?, ?)",
                  (data['name'], data['date'], data['platform'], data['review_content']))
        conn.commit()
        new_id = c.lastrowid

        new_review = c.execute("SELECT * FROM customer_reviews WHERE id = ?", (new_id,)).fetchone()

    socketio.emit('new_review', dict(new_review))

    return jsonify({'id': new_id, 'message': 'Review added successfully'}), 201

@app.route('/api/generate_review', methods=['POST'])
def generate_review():
    review = generate_random_review()
    
    with get_db_connection() as conn:
        c = conn.cursor()
        c.execute("INSERT INTO customer_reviews (name, date, platform, review_content) VALUES (?, ?, ?, ?)",
                  (review['name'], review['date'], review['platform'], review['review_content']))
        conn.commit()
        new_id = c.lastrowid

        new_review = c.execute("SELECT * FROM customer_reviews WHERE id = ?", (new_id,)).fetchone()

    socketio.emit('new_review', dict(new_review))

    return jsonify({'id': new_id, 'message': 'Random review generated and added successfully'}), 201

@app.route('/api/export_csv', methods=['GET'])
def export_csv():
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM customer_reviews ORDER BY timestamp DESC")
        rows = cursor.fetchall()

    output = io.StringIO()
    writer = csv.writer(output)
    
    writer.writerow(['id', 'name', 'date', 'platform', 'review_content', 'timestamp'])
    
    for row in rows:
        writer.writerow(row)

    output.seek(0)
    return send_file(
        io.BytesIO(output.getvalue().encode('utf-8')),
        mimetype='text/csv',
        as_attachment=True,
        download_name='customer_reviews.csv'
    )

@socketio.on('connect')
def handle_connect():
    print('Client connected')

@socketio.on('disconnect')
def handle_disconnect():
    print('Client disconnected')

if __name__ == '__main__':
    init_db()
    port = 9722
    print(f"Server running on port {port}")
    socketio.run(app, host='0.0.0.0', port=port, debug=True)
</SERVER_PYTHON_CODE>

This updated "server.py" file includes the following changes:

1. Changed the database name to 'customer_reviews.db'.
2. Modified the table structure to include "Name", "Date", "Platform", and "Review Content".
3. Removed the Agent-related functionality.
4. Added a new route '/api/generate_review' to generate and add a random review.
5. Updated the GET and POST routes for reviews.
6. Changed the port to 9722 as requested.

The random review generation function is implemented, and the CSV export functionality is updated to reflect the new data structure. The WebSocket functionality is kept to allow real-time updates when new reviews are added.
=== 2: user ===
Generate new "index.html"
=== 3: assistant ===
Certainly! Here's the updated "index.html" file that corresponds to the changes we made in the server:

<INDEX_HTML_CODE>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer Review Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        .table-container {
            max-height: 70vh;
            overflow-y: auto;
        }
        #reviewTable th, #reviewTable td {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }
        #reviewTable td.expanded {
            white-space: normal;
            max-width: none;
        }
        .expand-btn {
            cursor: pointer;
            user-select: none;
            transition: transform 0.3s ease;
        }
        .expand-btn.expanded {
            transform: rotate(180deg);
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <header class="bg-gray-600 text-white shadow-lg">
        <div class="container mx-auto px-4 py-6 flex justify-between items-center">
            <h1 class="text-3xl font-bold">Customer Review Manager</h1>
            <div class="flex items-center">
                <button id="generateReviewBtn" class="bg-green-500 text-white px-4 py-2 rounded-lg shadow hover:bg-green-600 transition duration-300 ease-in-out mr-2">
                    Generate Random Review
                </button>
                <button id="refreshBtn" class="bg-white text-indigo-600 px-4 py-2 rounded-lg shadow hover:bg-indigo-100 transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 mr-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-1" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
                    </svg>
                    Refresh
                </button>
                <button id="exportCsvBtn" class="bg-yellow-500 text-white px-4 py-2 rounded-lg shadow hover:bg-yellow-600 transition duration-300 ease-in-out">
                    Export CSV
                </button>
            </div>
        </div>
    </header>
    <main class="container mx-auto px-4 py-8">
        <div id="newReviewsAlert" class="hidden bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4" role="alert">
            <p class="font-bold">New reviews available!</p>
            <p>Click the button below to load the latest reviews.</p>
            <button id="loadNewReviewsBtn" class="mt-2 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                Load New Reviews
            </button>
        </div>
        <div class="bg-white rounded-lg shadow-md overflow-hidden">
            <div class="table-container">
                <table id="reviewTable" class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Expand</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ID</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Platform</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Review Content</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Timestamp</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200">
                        <!-- Table rows will be dynamically inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
        <div class="mt-4 flex justify-between items-center">
            <div>
                <span id="pageInfo" class="text-sm text-gray-600"></span>
            </div>
            <div>
                <button id="prevBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg shadow hover:bg-indigo-700 transition duration-300 ease-in-out mr-2">Previous</button>
                <button id="nextBtn" class="bg-indigo-600 text-white px-4 py-2 rounded-lg shadow hover:bg-indigo-700 transition duration-300 ease-in-out">Next</button>
            </div>
        </div>
        <div id="loadingSpinner" class="hidden fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2">
            <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-indigo-500"></div>
        </div>
    </main>
    <script>
        const API_URL = `http://${window.location.hostname}:9722/api`;
        const loadingSpinner = document.getElementById('loadingSpinner');
        const pageInfo = document.getElementById('pageInfo');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const generateReviewBtn = document.getElementById('generateReviewBtn');
        const newReviewsAlert = document.getElementById('newReviewsAlert');
        const loadNewReviewsBtn = document.getElementById('loadNewReviewsBtn');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        let currentPage = 1;
        let totalPages = 1;
        let totalReviews = 0;
        let newReviewsCount = 0;

        const socket = io(`http://${window.location.hostname}:9722`);

        socket.on('connect', () => {
            console.log('Connected to WebSocket');
        });

        socket.on('new_review', (review) => {
            console.log('New review received:', review);
            if (currentPage === 1) {
                prependReview(review);
            } else {
                newReviewsCount++;
                showNewReviewsAlert();
            }
            updateTotalReviews(totalReviews + 1);
        });

        async function fetchReviews(page = 1) {
            try {
                loadingSpinner.classList.remove('hidden');
                const response = await fetch(`${API_URL}/reviews?page=${page}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                updateTable(data.reviews);
                updatePagination(page, data.total_pages, data.total_reviews);
            } catch (error) {
                console.error('Error fetching reviews:', error);
            } finally {
                loadingSpinner.classList.add('hidden');
            }
        }

        function updateTable(reviews) {
            const tableBody = document.querySelector('#reviewTable tbody');
            tableBody.innerHTML = '';

            reviews.forEach(review => {
                const row = createTableRow(review);
                tableBody.appendChild(row);
            });
        }

        function createTableRow(review) {
            const row = document.createElement('tr');
            row.className = 'hover:bg-gray-50 transition duration-150 ease-in-out';
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                    <svg class="expand-btn w-5 h-5 text-gray-500 hover:text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${escapeHtml(review.id)}</td>
                <td class="px-6 py-4 text-sm font-medium text-gray-900">${escapeHtml(review.name)}</td>
                <td class="px-6 py-4 text-sm text-gray-500">${escapeHtml(review.date)}</td>
                <td class="px-6 py-4 text-sm text-gray-500">${escapeHtml(review.platform)}</td>
                <td class="px-6 py-4 text-sm text-gray-500">${escapeHtml(review.review_content)}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${new Date(review.timestamp).toLocaleString()}</td>
            `;

            const expandBtn = row.querySelector('.expand-btn');
            expandBtn.addEventListener('click', () => {
                const cells = row.querySelectorAll('td:not(:first-child)');
                cells.forEach(cell => cell.classList.toggle('expanded'));
                expandBtn.classList.toggle('expanded');
            });

            return row;
        }

        function prependReview(review) {
            const tableBody = document.querySelector('#reviewTable tbody');
            const row = createTableRow(review);
            tableBody.insertBefore(row, tableBody.firstChild);
            
            // Remove the last row if we have more than 10 reviews
            if (tableBody.children.length > 10) {
                tableBody.removeChild(tableBody.lastChild);
            }
        }

        function updatePagination(page, total, reviews) {
            currentPage = page;
            totalPages = total;
            totalReviews = reviews;
            pageInfo.textContent = `Page ${page} of ${total} (${reviews} total reviews)`;
            prevBtn.disabled = page === 1;
            nextBtn.disabled = page === total;
        }

        function updateTotalReviews(newTotal) {
            totalReviews = newTotal;
            totalPages = Math.ceil(totalReviews / 10);
            pageInfo.textContent = `Page ${currentPage} of ${totalPages} (${totalReviews} total reviews)`;
            nextBtn.disabled = currentPage === totalPages;
        }

        function showNewReviewsAlert() {
            newReviewsAlert.classList.remove('hidden');
            loadNewReviewsBtn.textContent = `Load ${newReviewsCount} New Reviews`;
        }

        function hideNewReviewsAlert() {
            newReviewsAlert.classList.add('hidden');
            newReviewsCount = 0;
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe === 'number') {
                return unsafe.toString();
            }
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }

        async function generateRandomReview() {
            try {
                const response = await fetch(`${API_URL}/generate_review`, { method: 'POST' });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('Random review generated:', data);
                if (currentPage === 1) {
                    fetchReviews(1);
                } else {
                    newReviewsCount++;
                    showNewReviewsAlert();
                }
            } catch (error) {
                console.error('Error generating random review:', error);
            }
        }

        async function exportCsv() {
            try {
                const response = await fetch(`${API_URL}/export_csv`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'customer_reviews.csv';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error exporting CSV:', error);
            }
        }

        prevBtn.addEventListener('click', () => {
            if (currentPage > 1) {
                fetchReviews(currentPage - 1);
            }
        });

        nextBtn.addEventListener('click', () => {
            if (currentPage < totalPages) {
                fetchReviews(currentPage + 1);
            }
        });

        document.getElementById('refreshBtn').addEventListener('click', () => fetchReviews(currentPage));
        generateReviewBtn.addEventListener('click', generateRandomReview);
        exportCsvBtn.addEventListener('click', exportCsv);

        loadNewReviewsBtn.addEventListener('click', () => {
            fetchReviews(1);
            hideNewReviewsAlert();
        });

        // Initial setup
        fetchReviews();
    </script>
</body>
</html>
</INDEX_HTML_CODE>

This updated "index.html" file includes the following changes:

1. Changed the title to "Customer Review Manager".
2. Updated the table structure to include "Name", "Date", "Platform", and "Review Content" columns.
3. Removed Agent-related elements.
4. Added a "Generate Random Review" button.
5. Updated the JavaScript code to work with the new review data structure.
6. Changed the API_URL to use port 9722.
7. Updated the generateRandomReview function to call the new API endpoint.
8. Adjusted the createTableRow function to display the new review data structure.

The overall layout and functionality remain similar to the original, but now it's focused on managing customer reviews instead of CRM entries. The random review generation feature has been implemented, and the CSV export functionality has been retained.
=== 4: user ===
Generate new "run.sh". Only add new missing install, no need to make big changes.

=== Reply 0 ===
Certainly! Here's the updated "run.sh" script with minimal changes, only adding the installation of any new missing dependencies:

<RUN_BASH_CODE>
#!/bin/bash

# Exit immediately if a command exits with a non-zero status
set -e

# Create a virtual environment if it doesn't exist
if [ ! -d "venv" ]; then
    echo "Creating virtual environment..."
    python3 -m venv venv
fi

# Activate the virtual environment
source venv/bin/activate

# Upgrade pip
pip install --upgrade pip

# Install required libraries
echo "Installing required libraries..."
pip install Flask flask-cors flask-socketio

# Start the server
echo "Starting the Customer Review Manager server..."
python server.py

# Keep the script running
while true; do
    echo "Customer Review Manager server is running on port 9722. Press Ctrl+C to stop."
    sleep 60
done
</RUN_BASH_CODE>

In this updated "run.sh" script, the changes are minimal:

1. Updated the echo message to reflect the new application name: "Customer Review Manager".
2. Changed the port number in the echo message to 9722 to match the new server configuration.

No new dependencies were added since the existing libraries (Flask, flask-cors, and flask-socketio) are sufficient for the updated application. The script still creates a virtual environment, installs the required libraries, and runs the server.py file.

This script will work with the new version of the application, setting up the environment and running the server just as before, but now for the Customer Review Manager instead of the Web Search & Scraper Agent.