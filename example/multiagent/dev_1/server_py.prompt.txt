claude-3-5-sonnet-20240620

You are Claude, an AI assistant powered by Anthropic's Claude-3.5-Sonnet model, specialized in backend development.
You are good at writing python webserver in single self-contained python files.

1. Regarding data or database.
If provide API key and mention API to use, generate client to actually connect to the API. (assume API is accesible and key is correct.)
Otherwise, generate mock data and prefer to use in-memory data-structure database.
When use sqlite, use local file database (in current directory).

2. You may use libraries like Flask, websocket and etc.
When use Flask, also enable CORS.

3. Bind to `localhost:5901`.

Output python source code should be included in <SERVER_PYTHON_CODE></SERVER_PYTHON_CODE> block.


=== 0: user ===
<PROBLEM>
agent: research an area and write a report.
</PROBLEM>

Design a list of agents, output in JSON format and put in <AGENTS_DESIGN></AGENTS_DESIGN> block.
(content in <AGENTS_DESIGN> will create file and written to "agents_design.json")

E.g.
```
<AGENTS_DESIGN>
[
  {
    "name": "Olivia Thompson",
    "goal": "Gather and analyze market data",
    "backstory": "Experienced market analyst with a keen eye for trends and patterns. Olivia has worked in various industries and excels at turning raw data into actionable insights."
  },
  {
    "name": "Marcus Chen",
    "goal": "Identify target audience and competitors",
    "backstory": "Former marketing strategist turned consultant. Marcus specializes in customer segmentation and competitive analysis, with a track record of helping startups position themselves effectively."
  },
  {
    "name": "Sophia Patel",
    "goal": "Synthesize information and craft compelling narratives",
    "backstory": "Skilled content writer and editor with a background in business journalism. Sophia has a talent for distilling complex information into clear, engaging prose."
  },
  {
    "name": "Ethan Novak",
    "goal": "Ensure accuracy and coherence of the final document",
    "backstory": "Meticulous proofreader and fact-checker with experience in academic publishing. Ethan has a broad knowledge base and a knack for spotting inconsistencies and gaps in information."
  }
]
</AGENTS_DESIGN>
```

=== 1: assistant ===
Here's a design for a team of agents to research an area and write a report, presented in JSON format:

<AGENTS_DESIGN>
[
  {
    "name": "Dr. Amelia Reeves",
    "goal": "Define research scope and methodology",
    "backstory": "Experienced research director with a Ph.D. in Information Science. Amelia excels at designing comprehensive research plans and ensuring projects stay on track."
  },
  {
    "name": "Lucas Ortiz",
    "goal": "Gather and analyze primary data",
    "backstory": "Skilled data scientist with expertise in both quantitative and qualitative research methods. Lucas has a talent for uncovering insights from complex datasets and conducting in-depth interviews."
  },
  {
    "name": "Zara Chen",
    "goal": "Conduct literature review and secondary research",
    "backstory": "Librarian turned research analyst with a knack for finding and synthesizing information from diverse sources. Zara is adept at using various databases and academic resources."
  },
  {
    "name": "Oliver Nkosi",
    "goal": "Interpret findings and develop key insights",
    "backstory": "Former management consultant with a background in strategy. Oliver specializes in connecting dots between different pieces of information and identifying actionable insights."
  },
  {
    "name": "Sophia Larsson",
    "goal": "Write and structure the report",
    "backstory": "Experienced technical writer with a background in journalism. Sophia excels at organizing complex information into clear, logical structures and writing engaging, accessible prose."
  },
  {
    "name": "Dr. Rajesh Patel",
    "goal": "Ensure scientific rigor and accuracy",
    "backstory": "Academic researcher and peer reviewer with expertise in multiple fields. Rajesh has a keen eye for methodological issues and ensures all claims are properly supported by evidence."
  },
  {
    "name": "Emma Dubois",
    "goal": "Create data visualizations and design report layout",
    "backstory": "Graphic designer specializing in data visualization and report design. Emma has a talent for presenting complex information in visually appealing and easily digestible formats."
  }
]
</AGENTS_DESIGN>
=== 2: user ===

Using these agents, think about a linear workflow to finish the task, each step has a "description", "agent" and "expected_output", the step output will be passing to the next step.
Output in JSON format and put in <TASKS_DESIGN></TASKS_DESIGN> block.
(content in <TASKS_DESIGN> will create file and written to "tasks_design.json")

E.g.
```
<TASKS_DESIGN>
[
  {
    "step": 1,
    "description": "Gather relevant market data and statistics",
    "expected_output": "Compiled market data in JSON format, including market size, growth rate, and key trends",
    "agent": "Olivia Thompson"
  },
  {
    "step": 2,
    "description": "Analyze target audience and identify main competitors",
    "expected_output": "JSON document containing target audience segments and a list of top competitors with their market shares",
    "agent": "Marcus Chen"
  },
  {
    "step": 3,
    "description": "Analyze gathered data and extract key insights",
    "expected_output": "List of key insights and their implications for the market",
    "agent": "Olivia Thompson"
  },
  {
    "step": 4,
    "description": "Create an outline for the 1-pager based on gathered information",
    "expected_output": "Detailed outline of the 1-pager in markdown format",
    "agent": "Sophia Patel"
  },
  {
    "step": 5,
    "description": "Write the first draft of the market research 1-pager",
    "expected_output": "First draft of the 1-pager in markdown format",
    "agent": "Sophia Patel"
  },
  {
    "step": 6,
    "description": "Review and fact-check the first draft",
    "expected_output": "Reviewed document with suggestions for improvements and corrections",
    "agent": "Ethan Novak"
  },
  {
    "step": 7,
    "description": "Incorporate feedback and finalize the 1-pager",
    "expected_output": "Final version of the market research 1-pager in markdown format",
    "agent": "Sophia Patel"
  },
  {
    "step": 8,
    "description": "Perform final proofreading and quality check",
    "expected_output": "Proofread and approved market research 1-pager, ready for presentation",
    "agent": "Ethan Novak"
  }
]
</TASKS_DESIGN>
```

=== 3: assistant ===
Here's a linear workflow using the designed agents to research an area and write a report:

<TASKS_DESIGN>
[
  {
    "step": 1,
    "description": "Define research scope, objectives, and methodology",
    "expected_output": "Detailed research plan including research questions, methodology, and timeline",
    "agent": "Dr. Amelia Reeves"
  },
  {
    "step": 2,
    "description": "Conduct literature review and gather secondary research",
    "expected_output": "Comprehensive literature review document with key findings and sources",
    "agent": "Zara Chen"
  },
  {
    "step": 3,
    "description": "Design and conduct primary research (surveys, interviews, etc.)",
    "expected_output": "Raw data from primary research activities in structured format (e.g., CSV, JSON)",
    "agent": "Lucas Ortiz"
  },
  {
    "step": 4,
    "description": "Analyze primary data and extract key insights",
    "expected_output": "Analysis report with statistical findings and qualitative insights",
    "agent": "Lucas Ortiz"
  },
  {
    "step": 5,
    "description": "Synthesize findings from primary and secondary research",
    "expected_output": "Comprehensive synthesis document highlighting main findings and their implications",
    "agent": "Oliver Nkosi"
  },
  {
    "step": 6,
    "description": "Create data visualizations for key findings",
    "expected_output": "Set of charts, graphs, and infographics illustrating main research results",
    "agent": "Emma Dubois"
  },
  {
    "step": 7,
    "description": "Develop report outline and structure",
    "expected_output": "Detailed report outline with sections and subsections",
    "agent": "Sophia Larsson"
  },
  {
    "step": 8,
    "description": "Write first draft of the report",
    "expected_output": "First draft of the full research report in markdown format",
    "agent": "Sophia Larsson"
  },
  {
    "step": 9,
    "description": "Review report for scientific rigor and accuracy",
    "expected_output": "Reviewed document with suggestions for improvements and corrections",
    "agent": "Dr. Rajesh Patel"
  },
  {
    "step": 10,
    "description": "Incorporate feedback and refine report",
    "expected_output": "Revised draft of the research report",
    "agent": "Sophia Larsson"
  },
  {
    "step": 11,
    "description": "Design final report layout and integrate visualizations",
    "expected_output": "Formatted report with integrated graphics and consistent design",
    "agent": "Emma Dubois"
  },
  {
    "step": 12,
    "description": "Conduct final review and proofreading",
    "expected_output": "Final, polished research report ready for submission",
    "agent": "Dr. Amelia Reeves"
  }
]
</TASKS_DESIGN>
=== 4: user ===
Based on "agents_design.json" and "tasks_design.json", implement "agents.py"
=== 5: assistant ===
Certainly! I'll implement the "agents.py" file based on the provided "agents_design.json" and "tasks_design.json". This implementation will use the CrewAI library to create a multi-agent workflow for researching an area and writing a report.

<AGENTS_PYTHON_CODE>
import os
from crewai import Agent, Task, Crew, Process
from langchain_anthropic import ChatAnthropic
from langchain_community.tools import DuckDuckGoSearchRun

# Set up the language model
model = 'claude-3-5-sonnet-20240620'
os.environ["ANTHROPIC_API_KEY"] = 'your_anthropic_api_key_here'
llm = ChatAnthropic(model=model, temperature=0.2)

# Initialize tools
search_tool = DuckDuckGoSearchRun()

# Create agents
dr_amelia_reeves = Agent(
    role='Research Director',
    goal='Define research scope and methodology',
    backstory='Experienced research director with a Ph.D. in Information Science. Amelia excels at designing comprehensive research plans and ensuring projects stay on track.',
    tools=[search_tool],
    llm=llm
)

lucas_ortiz = Agent(
    role='Data Scientist',
    goal='Gather and analyze primary data',
    backstory='Skilled data scientist with expertise in both quantitative and qualitative research methods. Lucas has a talent for uncovering insights from complex datasets and conducting in-depth interviews.',
    tools=[search_tool],
    llm=llm
)

zara_chen = Agent(
    role='Research Analyst',
    goal='Conduct literature review and secondary research',
    backstory='Librarian turned research analyst with a knack for finding and synthesizing information from diverse sources. Zara is adept at using various databases and academic resources.',
    tools=[search_tool],
    llm=llm
)

oliver_nkosi = Agent(
    role='Insights Specialist',
    goal='Interpret findings and develop key insights',
    backstory='Former management consultant with a background in strategy. Oliver specializes in connecting dots between different pieces of information and identifying actionable insights.',
    tools=[search_tool],
    llm=llm
)

sophia_larsson = Agent(
    role='Technical Writer',
    goal='Write and structure the report',
    backstory='Experienced technical writer with a background in journalism. Sophia excels at organizing complex information into clear, logical structures and writing engaging, accessible prose.',
    tools=[search_tool],
    llm=llm
)

dr_rajesh_patel = Agent(
    role='Scientific Reviewer',
    goal='Ensure scientific rigor and accuracy',
    backstory='Academic researcher and peer reviewer with expertise in multiple fields. Rajesh has a keen eye for methodological issues and ensures all claims are properly supported by evidence.',
    tools=[search_tool],
    llm=llm
)

emma_dubois = Agent(
    role='Data Visualization Specialist',
    goal='Create data visualizations and design report layout',
    backstory='Graphic designer specializing in data visualization and report design. Emma has a talent for presenting complex information in visually appealing and easily digestible formats.',
    tools=[search_tool],
    llm=llm
)

# Create tasks
tasks = [
    Task(
        description="Define research scope, objectives, and methodology",
        agent=dr_amelia_reeves,
        expected_output="Detailed research plan including research questions, methodology, and timeline"
    ),
    Task(
        description="Conduct literature review and gather secondary research",
        agent=zara_chen,
        expected_output="Comprehensive literature review document with key findings and sources"
    ),
    Task(
        description="Design and conduct primary research (surveys, interviews, etc.)",
        agent=lucas_ortiz,
        expected_output="Raw data from primary research activities in structured format (e.g., CSV, JSON)"
    ),
    Task(
        description="Analyze primary data and extract key insights",
        agent=lucas_ortiz,
        expected_output="Analysis report with statistical findings and qualitative insights"
    ),
    Task(
        description="Synthesize findings from primary and secondary research",
        agent=oliver_nkosi,
        expected_output="Comprehensive synthesis document highlighting main findings and their implications"
    ),
    Task(
        description="Create data visualizations for key findings",
        agent=emma_dubois,
        expected_output="Set of charts, graphs, and infographics illustrating main research results"
    ),
    Task(
        description="Develop report outline and structure",
        agent=sophia_larsson,
        expected_output="Detailed report outline with sections and subsections"
    ),
    Task(
        description="Write first draft of the report",
        agent=sophia_larsson,
        expected_output="First draft of the full research report in markdown format"
    ),
    Task(
        description="Review report for scientific rigor and accuracy",
        agent=dr_rajesh_patel,
        expected_output="Reviewed document with suggestions for improvements and corrections"
    ),
    Task(
        description="Incorporate feedback and refine report",
        agent=sophia_larsson,
        expected_output="Revised draft of the research report"
    ),
    Task(
        description="Design final report layout and integrate visualizations",
        agent=emma_dubois,
        expected_output="Formatted report with integrated graphics and consistent design"
    ),
    Task(
        description="Conduct final review and proofreading",
        agent=dr_amelia_reeves,
        expected_output="Final, polished research report ready for submission"
    )
]

# Create the crew
crew = Crew(
    agents=[dr_amelia_reeves, lucas_ortiz, zara_chen, oliver_nkosi, sophia_larsson, dr_rajesh_patel, emma_dubois],
    tasks=tasks,
    process=Process.sequential
)

# Function to run the research and report writing process
def research_and_write_report(topic):
    print(f"Starting research and report writing process on the topic: {topic}")
    result = crew.kickoff()
    print("Research and report writing process completed.")
    return result

# Example usage
if __name__ == "__main__":
    research_topic = "The impact of artificial intelligence on job markets in the next decade"
    final_report = research_and_write_report(research_topic)
    print("Final Report:")
    print(final_report)
</AGENTS_PYTHON_CODE>

This implementation creates a multi-agent workflow using the CrewAI library to research an area and write a report. Here's a breakdown of the code:

1. We import the necessary libraries and set up the language model (ChatAnthropic).

2. We create Agent instances for each of the roles defined in the "agents_design.json" file.

3. We define Task instances based on the "tasks_design.json" file, assigning each task to the appropriate agent.

4. We create a Crew instance with all the agents and tasks, setting the process to sequential.

5. We define a `research_and_write_report` function that takes a research topic as input and runs the entire workflow.

6. In the `if __name__ == "__main__":` block, we provide an example of how to use the function with a sample research topic.

To use this code:

1. Replace 'your_anthropic_api_key_here' with your actual Anthropic API key.
2. Ensure you have the required libraries installed (crewai, langchain_anthropic, langchain_community).
3. Run the script, providing a research topic when prompted.

The script will execute the entire research and report writing process, with each agent performing their assigned tasks sequentially. The final output will be a comprehensive research report on the given topic.
=== 6: user ===
Given the multi-agent design and implementation "agents.py", brainstorm backend/frontend system designs.

Backend should expose APIs to control the agents executions and reflect the status of execution, and results.
Frontend should have UX component to refect each agents, the overall workflow, the execution status of the workflow and results.   

generate <BACKEND_DESIGN> and <FRONTEND_DESIGN>.

=== 7: assistant ===
Certainly! I'll design a backend and frontend system that integrates with the multi-agent implementation in "agents.py". This system will allow users to control the agents' execution, monitor the status, and view the results.

<BACKEND_DESIGN>
1. Flask-based RESTful API:
   - Use Flask to create a lightweight web server exposing RESTful APIs.

2. Endpoints:
   a. POST /research
      - Input: JSON with research topic
      - Output: Job ID for the research task
   b. GET /research/{job_id}/status
      - Output: Current status of the research job (e.g., "in progress", "completed")
   c. GET /research/{job_id}/results
      - Output: Final research report or current progress
   d. GET /agents
      - Output: List of all agents and their details
   e. GET /workflow
      - Output: Current workflow structure

3. Background Task Queue:
   - Use Celery for managing long-running research tasks asynchronously

4. Database:
   - Use SQLAlchemy with SQLite for storing job statuses, results, and agent information

5. WebSocket for Real-time Updates:
   - Implement Socket.IO to push real-time updates about job progress to the frontend

6. Error Handling and Logging:
   - Implement robust error handling and logging for debugging and monitoring

7. Authentication and Rate Limiting:
   - Implement JWT-based authentication for API access
   - Use Flask-Limiter for rate limiting to prevent abuse

Pseudocode for main app structure:

```python
from flask import Flask, request, jsonify
from flask_socketio import SocketIO
from celery import Celery
from models import db, Research, Agent
from agents import research_and_write_report

app = Flask(__name__)
socketio = SocketIO(app)
celery = Celery(app.name, broker='redis://localhost:6379/0')

@app.route('/research', methods=['POST'])
def start_research():
    topic = request.json['topic']
    job = celery.send_task('tasks.research_task', args=[topic])
    return jsonify({'job_id': job.id}), 202

@app.route('/research/<job_id>/status', methods=['GET'])
def get_research_status(job_id):
    job = Research.query.get(job_id)
    return jsonify({'status': job.status})

@app.route('/research/<job_id>/results', methods=['GET'])
def get_research_results(job_id):
    job = Research.query.get(job_id)
    return jsonify({'results': job.results})

@app.route('/agents', methods=['GET'])
def get_agents():
    agents = Agent.query.all()
    return jsonify([agent.to_dict() for agent in agents])

@app.route('/workflow', methods=['GET'])
def get_workflow():
    # Return the current workflow structure
    pass

@celery.task(name='tasks.research_task')
def research_task(topic):
    result = research_and_write_report(topic)
    # Update database and send WebSocket notification
    socketio.emit('research_update', {'status': 'completed', 'result': result})

if __name__ == '__main__':
    socketio.run(app)
```
</BACKEND_DESIGN>

<FRONTEND_DESIGN>
1. React-based Single Page Application:
   - Use Create React App for quick setup and development

2. Main Components:
   a. ResearchForm
      - Input field for research topic
      - Submit button to start research
   b. AgentList
      - Display all agents with their roles and goals
   c. WorkflowVisualization
      - Visual representation of the research workflow
      - Use a library like react-flow for creating an interactive flow diagram
   d. ResearchStatus
      - Show current status of ongoing research
      - Display progress through the workflow steps
   e. ResultsViewer
      - Display the final research report or current progress
   f. Notifications
      - Show real-time updates and notifications

3. State Management:
   - Use Redux for global state management
   - Store research jobs, agent information, and workflow status

4. API Integration:
   - Use Axios for making HTTP requests to the backend API

5. Real-time Updates:
   - Implement Socket.IO client for receiving real-time updates from the server

6. Styling:
   - Use Material-UI for consistent and responsive design

7. Routing:
   - Implement React Router for navigation between different views

Pseudocode for main App component:

```jsx
import React, { useEffect } from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import { useDispatch } from 'react-redux';
import io from 'socket.io-client';
import ResearchForm from './components/ResearchForm';
import AgentList from './components/AgentList';
import WorkflowVisualization from './components/WorkflowVisualization';
import ResearchStatus from './components/ResearchStatus';
import ResultsViewer from './components/ResultsViewer';
import Notifications from './components/Notifications';

const App = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    const socket = io('http://localhost:5000');
    socket.on('research_update', (data) => {
      dispatch({ type: 'UPDATE_RESEARCH', payload: data });
    });

    return () => socket.disconnect();
  }, []);

  return (
    <Router>
      <div className="app">
        <header>
          <h1>Multi-Agent Research System</h1>
        </header>
        <main>
          <Switch>
            <Route exact path="/">
              <ResearchForm />
              <AgentList />
              <WorkflowVisualization />
            </Route>
            <Route path="/research/:jobId">
              <ResearchStatus />
              <ResultsViewer />
            </Route>
          </Switch>
        </main>
        <Notifications />
      </div>
    </Router>
  );
};

export default App;
```

Key features of the frontend design:
1. The main page displays the research form, agent list, and workflow visualization.
2. When a research job is started, the user is redirected to a page showing the research status and results.
3. Real-time updates are received via WebSocket and dispatched to the Redux store.
4. The UI is responsive and user-friendly, allowing easy monitoring of the research process.
5. The workflow visualization provides an intuitive representation of the multi-agent system's operation.
</FRONTEND_DESIGN>

This backend and frontend design creates a comprehensive system for managing and visualizing the multi-agent research process. The backend provides a robust API for controlling the agents and retrieving results, while the frontend offers an intuitive interface for users to interact with the system and monitor progress in real-time.
=== 8: user ===
Based on <BACKEND_DESIGN>, generate "server.py".
1. The python server should expose APIs to control the agents executions and reflect the status of execution, and results.
2. Serve "index.html" like a static web server.
3. Try not to use any task framework e.g. Celery.


=== Reply 0 ===
Certainly! I'll create a "server.py" file based on the <BACKEND_DESIGN> with the modifications you requested. This server will expose APIs to control agent executions, reflect execution status and results, serve a static "index.html" file, and avoid using task frameworks like Celery.

Here's the implementation:

<SERVER_PYTHON_CODE>
import os
import json
import uuid
from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from flask_socketio import SocketIO
from threading import Thread
from agents import research_and_write_report

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

# In-memory storage for simplicity
research_jobs = {}
agents = [
    {"name": "Dr. Amelia Reeves", "role": "Research Director"},
    {"name": "Lucas Ortiz", "role": "Data Scientist"},
    {"name": "Zara Chen", "role": "Research Analyst"},
    {"name": "Oliver Nkosi", "role": "Insights Specialist"},
    {"name": "Sophia Larsson", "role": "Technical Writer"},
    {"name": "Dr. Rajesh Patel", "role": "Scientific Reviewer"},
    {"name": "Emma Dubois", "role": "Data Visualization Specialist"}
]

workflow = [
    "Define research scope",
    "Conduct literature review",
    "Design and conduct primary research",
    "Analyze primary data",
    "Synthesize findings",
    "Create data visualizations",
    "Develop report outline",
    "Write first draft",
    "Review for scientific rigor",
    "Incorporate feedback",
    "Design final layout",
    "Conduct final review"
]

def run_research(job_id, topic):
    research_jobs[job_id]['status'] = 'in_progress'
    socketio.emit('research_update', {'job_id': job_id, 'status': 'in_progress'})

    for i, step in enumerate(workflow):
        research_jobs[job_id]['current_step'] = i + 1
        socketio.emit('research_update', {
            'job_id': job_id,
            'status': 'in_progress',
            'current_step': i + 1,
            'total_steps': len(workflow)
        })
        # Simulate work being done
        socketio.sleep(5)

    result = research_and_write_report(topic)
    research_jobs[job_id]['status'] = 'completed'
    research_jobs[job_id]['result'] = result
    socketio.emit('research_update', {
        'job_id': job_id,
        'status': 'completed',
        'result': result
    })

@app.route('/')
def serve_index():
    return send_from_directory('.', 'index.html')

@app.route('/api/research', methods=['POST'])
def start_research():
    topic = request.json['topic']
    job_id = str(uuid.uuid4())
    research_jobs[job_id] = {'status': 'pending', 'topic': topic}
    Thread(target=run_research, args=(job_id, topic)).start()
    return jsonify({'job_id': job_id}), 202

@app.route('/api/research/<job_id>/status', methods=['GET'])
def get_research_status(job_id):
    job = research_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    return jsonify({
        'status': job['status'],
        'current_step': job.get('current_step', 0),
        'total_steps': len(workflow)
    })

@app.route('/api/research/<job_id>/results', methods=['GET'])
def get_research_results(job_id):
    job = research_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    if job['status'] != 'completed':
        return jsonify({'error': 'Research not completed yet'}), 400
    return jsonify({'results': job['result']})

@app.route('/api/agents', methods=['GET'])
def get_agents():
    return jsonify(agents)

@app.route('/api/workflow', methods=['GET'])
def get_workflow():
    return jsonify(workflow)

if __name__ == '__main__':
    socketio.run(app, host='localhost', port=5901, debug=True)
</SERVER_PYTHON_CODE>

This implementation does the following:

1. It uses Flask to create a web server that exposes APIs to control agent executions and reflect the status of execution and results.

2. It serves "index.html" as a static file when the root URL is accessed.

3. Instead of using Celery, it uses Python's built-in `threading` module to run research tasks asynchronously.

4. It implements the following API endpoints:
   - POST /api/research: Start a new research job
   - GET /api/research/{job_id}/status: Get the status of a research job
   - GET /api/research/{job_id}/results: Get the results of a completed research job
   - GET /api/agents: Get the list of agents
   - GET /api/workflow: Get the workflow steps

5. It uses Flask-SocketIO to provide real-time updates on research progress.

6. It uses in-memory storage (Python dictionaries) to store job information for simplicity. In a production environment, you'd want to use a database for persistence.

7. The server runs on localhost:5901 as requested.

To use this server:

1. Make sure you have the required dependencies installed (Flask, Flask-CORS, Flask-SocketIO).
2. Place this "server.py" file in the same directory as your "agents.py" file and an "index.html" file.
3. Run the server using `python server.py`.

Note that this implementation simulates the research process for demonstration purposes. In a real-world scenario, you would replace the simulation in the `run_research` function with actual calls to your agent functions from "agents.py".