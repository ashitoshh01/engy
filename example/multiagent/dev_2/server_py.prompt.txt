claude-3-5-sonnet-20240620

You are Claude, an AI assistant powered by Anthropic's Claude-3.5-Sonnet model, specialized in backend development.
You are good at writing python webserver in single self-contained python files.

1. Regarding data or database.
If provide API key and mention API to use, generate client to actually connect to the API. (assume API is accesible and key is correct.)
Otherwise, generate mock data and prefer to use in-memory data-structure database.
When use sqlite, use local file database (in current directory).

2. You may use libraries like Flask, websocket and etc.
When use Flask, also enable CORS.

3. Bind to `localhost:7457`.

Output python source code should be included in <SERVER_PYTHON_CODE></SERVER_PYTHON_CODE> block.


=== 0: user ===
<PROBLEM>
Create agents help me to evaluate a given idea how much chance to be accepted by YC.
Investigate recent accepted applications in recent batchs.
Do thorough analysis why they be accepted and evaluate ours.
</PROBLEM>

Design a list of agents, output in JSON format and put in <AGENTS_DESIGN></AGENTS_DESIGN> block.
(content in <AGENTS_DESIGN> will create file and written to "agents_design.json")

E.g.
```
<AGENTS_DESIGN>
[
  {
    "name": "Olivia Thompson",
    "goal": "Gather and analyze market data",
    "backstory": "Experienced market analyst with a keen eye for trends and patterns. Olivia has worked in various industries and excels at turning raw data into actionable insights.",
    "tools": ["search_tool", "scrape_tool", "duckduck_tool"]
  },
  {
    "name": "Marcus Chen",
    "goal": "Identify target audience and competitors",
    "backstory": "Former marketing strategist turned consultant. Marcus specializes in customer segmentation and competitive analysis, with a track record of helping startups position themselves effectively.",
    "tools": ["search_tool", "scrape_tool", "duckduck_tool"]
  },
  {
    "name": "Sophia Patel",
    "goal": "Synthesize information and craft compelling narratives",
    "backstory": "Skilled content writer and editor with a background in business journalism. Sophia has a talent for distilling complex information into clear, engaging prose.",
    "tools": ["search_tool", "scrape_tool", "duckduck_tool"]
  },
  {
    "name": "Ethan Novak",
    "goal": "Ensure accuracy and coherence of the final document",
    "backstory": "Meticulous proofreader and fact-checker with experience in academic publishing. Ethan has a broad knowledge base and a knack for spotting inconsistencies and gaps in information.",
    "tools": ["search_tool", "scrape_tool", "duckduck_tool"]
  }
]
</AGENTS_DESIGN>
```

=== 1: assistant ===
Certainly! I'll design a multi-agent system to evaluate an idea's chances of being accepted by Y Combinator (YC) and analyze recent accepted applications. Here's the JSON format of the agents designed for this task:

<AGENTS_DESIGN>
[
  {
    "name": "Alex DataMiner",
    "goal": "Gather and analyze data on recent YC accepted applications",
    "backstory": "Former data scientist at a top tech company, Alex specializes in collecting and analyzing large datasets. They have a keen eye for patterns and trends in startup ecosystems.",
    "tools": ["search_tool", "scrape_tool", "data_analysis_tool"]
  },
  {
    "name": "Samantha YCInsider",
    "goal": "Provide insights on YC selection criteria and preferences",
    "backstory": "Ex-YC partner with years of experience in evaluating startup applications. Samantha has a deep understanding of what YC looks for in potential investments.",
    "tools": ["search_tool", "yc_database_tool"]
  },
  {
    "name": "Marcus TrendSpotter",
    "goal": "Identify current market trends and emerging technologies",
    "backstory": "Tech journalist turned market analyst, Marcus has a finger on the pulse of the startup world. He excels at identifying upcoming trends and assessing their potential impact.",
    "tools": ["search_tool", "news_aggregator_tool", "social_media_analysis_tool"]
  },
  {
    "name": "Olivia PitchPerfector",
    "goal": "Analyze and improve pitch strategies",
    "backstory": "Startup pitch coach with a track record of helping founders secure funding. Olivia has a talent for crafting compelling narratives and identifying key selling points.",
    "tools": ["search_tool", "language_analysis_tool"]
  },
  {
    "name": "Ryan CompAnalyst",
    "goal": "Conduct competitive analysis and market positioning",
    "backstory": "Former strategy consultant specializing in startup ecosystems. Ryan excels at mapping out competitive landscapes and identifying unique value propositions.",
    "tools": ["search_tool", "market_analysis_tool", "competitor_tracking_tool"]
  },
  {
    "name": "Emily TechEvaluator",
    "goal": "Assess technical feasibility and innovation of ideas",
    "backstory": "Software engineer with experience in multiple startups. Emily has a broad understanding of various technologies and can evaluate the technical merit of startup ideas.",
    "tools": ["search_tool", "code_analysis_tool", "tech_stack_evaluator_tool"]
  },
  {
    "name": "David SynthesisGuru",
    "goal": "Synthesize information and generate final evaluation report",
    "backstory": "Experienced business writer and analyst, David has a talent for integrating diverse information into coherent, actionable reports. He ensures all aspects of the evaluation are considered and well-presented.",
    "tools": ["search_tool", "document_creation_tool", "data_visualization_tool"]
  }
]
</AGENTS_DESIGN>

This multi-agent system is designed to comprehensively evaluate an idea's chances of being accepted by YC by analyzing recent accepted applications and conducting a thorough analysis. Each agent has a specific role and set of skills to contribute to the overall evaluation process.
=== 2: user ===

Using these agents, think about a linear workflow to finish the task, each step has a "description", "agent" and "expected_output", the step output will be passing to the next step.
Output in JSON format and put in <TASKS_DESIGN></TASKS_DESIGN> block.
(content in <TASKS_DESIGN> will create file and written to "tasks_design.json")

E.g.
```
<TASKS_DESIGN>
[
  {
    "step": 1,
    "description": "Gather relevant market data and statistics",
    "expected_output": "Compiled market data in JSON format, including market size, growth rate, and key trends",
    "agent": "Olivia Thompson",
  },
  {
    "step": 2,
    "description": "Analyze target audience and identify main competitors",
    "expected_output": "JSON document containing target audience segments and a list of top competitors with their market shares",
    "agent": "Marcus Chen"
  },
  {
    "step": 3,
    "description": "Analyze gathered data and extract key insights",
    "expected_output": "List of key insights and their implications for the market",
    "agent": "Olivia Thompson"
  },
  {
    "step": 4,
    "description": "Create an outline for the 1-pager based on gathered information",
    "expected_output": "Detailed outline of the 1-pager in markdown format",
    "agent": "Sophia Patel"
  },
  {
    "step": 5,
    "description": "Write the first draft of the market research 1-pager",
    "expected_output": "First draft of the 1-pager in markdown format",
    "agent": "Sophia Patel"
  },
  {
    "step": 6,
    "description": "Review and fact-check the first draft",
    "expected_output": "Reviewed document with suggestions for improvements and corrections",
    "agent": "Ethan Novak"
  },
  {
    "step": 7,
    "description": "Incorporate feedback and finalize the 1-pager",
    "expected_output": "Final version of the market research 1-pager in markdown format",
    "agent": "Sophia Patel"
  },
  {
    "step": 8,
    "description": "Perform final proofreading and quality check",
    "expected_output": "Proofread and approved market research 1-pager, ready for presentation",
    "agent": "Ethan Novak"
  }
]
</TASKS_DESIGN>
```

=== 3: assistant ===
Certainly! I'll create a linear workflow using the agents we've designed to evaluate an idea's chances of being accepted by YC. Here's the JSON format of the tasks designed for this process:

<TASKS_DESIGN>
[
  {
    "step": 1,
    "description": "Gather and analyze data on recent YC accepted applications",
    "expected_output": "JSON document containing detailed information on recent YC accepted startups, including industry, funding, team composition, and key metrics",
    "agent": "Alex DataMiner"
  },
  {
    "step": 2,
    "description": "Identify current YC selection criteria and preferences",
    "expected_output": "Report outlining YC's current selection criteria, preferences, and any recent shifts in investment focus",
    "agent": "Samantha YCInsider"
  },
  {
    "step": 3,
    "description": "Analyze current market trends and emerging technologies",
    "expected_output": "List of top market trends and emerging technologies relevant to YC's interests, with supporting data",
    "agent": "Marcus TrendSpotter"
  },
  {
    "step": 4,
    "description": "Evaluate the given idea against YC criteria and market trends",
    "expected_output": "Initial assessment report comparing the given idea to YC criteria and current market trends",
    "agent": "Ryan CompAnalyst"
  },
  {
    "step": 5,
    "description": "Assess technical feasibility and innovation of the idea",
    "expected_output": "Technical evaluation report detailing the idea's feasibility, innovativeness, and potential technical challenges",
    "agent": "Emily TechEvaluator"
  },
  {
    "step": 6,
    "description": "Analyze and suggest improvements for the idea's pitch strategy",
    "expected_output": "Pitch analysis report with specific recommendations for improvement",
    "agent": "Olivia PitchPerfector"
  },
  {
    "step": 7,
    "description": "Conduct competitive analysis and market positioning",
    "expected_output": "Competitive landscape report and suggested market positioning strategy",
    "agent": "Ryan CompAnalyst"
  },
  {
    "step": 8,
    "description": "Synthesize all gathered information and generate final evaluation report",
    "expected_output": "Comprehensive evaluation report assessing the idea's chances of YC acceptance, including strengths, weaknesses, and recommendations",
    "agent": "David SynthesisGuru"
  }
]
</TASKS_DESIGN>

This workflow is designed to systematically evaluate the given idea's chances of being accepted by YC. It starts with gathering data on recent YC acceptances and understanding YC's current preferences, then moves on to analyzing market trends and the specific idea. The process includes technical evaluation, pitch analysis, and competitive positioning before culminating in a comprehensive final report. Each step builds on the previous ones, with the output of each task serving as input for the next, ensuring a thorough and well-rounded evaluation.
=== 4: user ===
Implement the agents/tasks design based on modifying this code example.

<code_example>
import os
import uuid
from threading import Thread

from crewai import Agent, Crew, Process, Task
from dotenv import load_dotenv
from flask import Flask, jsonify, request, send_from_directory
from flask_cors import CORS
from flask_socketio import SocketIO
from langchain_anthropic import ChatAnthropic
from langchain_community.tools import DuckDuckGoSearchRun
from langchain_core.agents import AgentFinish
from crewai_tools import ScrapeWebsiteTool, SerperDevTool

# Assume ANTHROPIC_API_KEY and other keys have been set in .env file.
load_dotenv()

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

# Set up the language model
model = 'claude-3-haiku-20240307'
llm = ChatAnthropic(model=model, temperature=0.2)

# Initialize tools
duck_tool = DuckDuckGoSearchRun()
search_tool = SerperDevTool()
scrape_tool = ScrapeWebsiteTool()

# Create agents
dr_amelia_reeves = Agent(
    role='Research Director',
    goal='Define research scope and methodology',
    backstory='Experienced research director with a Ph.D. in Information Science. Amelia excels at designing comprehensive research plans and ensuring projects stay on track.',
    tools=[search_tool, duck_tool],
    llm=llm
)

lucas_ortiz = Agent(
    role='Data Scientist',
    goal='Gather and analyze primary data',
    backstory='Skilled data scientist with expertise in both quantitative and qualitative research methods. Lucas has a talent for uncovering insights from complex datasets and conducting in-depth interviews.',
    tools=[search_tool, scrape_tool],
    llm=llm
)

zara_chen = Agent(
    role='Research Analyst',
    goal='Conduct literature review and secondary research',
    backstory='Librarian turned research analyst with a knack for finding and synthesizing information from diverse sources. Zara is adept at using various databases and academic resources.',
    tools=[search_tool, scrape_tool, duck_tool],
    llm=llm
)

oliver_nkosi = Agent(
    role='Insights Specialist',
    goal='Interpret findings and develop key insights',
    backstory='Former management consultant with a background in strategy. Oliver specializes in connecting dots between different pieces of information and identifying actionable insights.',
    tools=[search_tool, scrape_tool, duck_tool],
    llm=llm
)

sophia_larsson = Agent(
    role='Technical Writer',
    goal='Write and structure the report',
    backstory='Experienced technical writer with a background in journalism. Sophia excels at organizing complex information into clear, logical structures and writing engaging, accessible prose.',
    tools=[search_tool, scrape_tool, duck_tool],
    llm=llm
)

dr_rajesh_patel = Agent(
    role='Scientific Reviewer',
    goal='Ensure scientific rigor and accuracy',
    backstory='Academic researcher and peer reviewer with expertise in multiple fields. Rajesh has a keen eye for methodological issues and ensures all claims are properly supported by evidence.',
    tools=[search_tool, scrape_tool, duck_tool],
    llm=llm
)

emma_dubois = Agent(
    role='Data Visualization Specialist',
    goal='Create data visualizations and design report layout',
    backstory='Graphic designer specializing in data visualization and report design. Emma has a talent for presenting complex information in visually appealing and easily digestible formats.',
    tools=[search_tool, scrape_tool, duck_tool],
    llm=llm
)

# In-memory storage for simplicity
research_jobs = {}

agents = [
    {"name": "Dr. Amelia Reeves", "role": "Research Director"},
    {"name": "Lucas Ortiz", "role": "Data Scientist"},
    {"name": "Zara Chen", "role": "Research Analyst"},
    {"name": "Oliver Nkosi", "role": "Insights Specialist"},
    {"name": "Sophia Larsson", "role": "Technical Writer"},
    {"name": "Dr. Rajesh Patel", "role": "Scientific Reviewer"},
    {"name": "Emma Dubois", "role": "Data Visualization Specialist"}
]

workflow = [
    "Define research scope",
    "Conduct literature review",
    "Design and conduct primary research",
    "Analyze primary data",
    "Synthesize findings",
    "Create data visualizations",
    "Develop report outline",
    "Write first draft",
    "Review for scientific rigor",
    "Incorporate feedback",
    "Design final layout",
    "Conduct final review"
]

# Step callback function


def step_callback(job_id, step_output):
    if isinstance(step_output, AgentFinish):
        status = "completed"
        result = step_output.return_values.get('output', '')
    else:
        status = "in_progress"
        result = str(step_output)

    current_step = research_jobs[job_id].get('current_step', 0)
    current_agent = get_agent_for_step(current_step)

    research_jobs[job_id]['current_step'] = current_step
    research_jobs[job_id]['current_agent'] = current_agent
    research_jobs[job_id]['tasks'][current_step - 1]['status'] = status
    research_jobs[job_id]['tasks'][current_step - 1]['result'] = result

    socketio.emit('research_update', {
        'job_id': job_id,
        'status': status,
        'result': result,
        'current_step': current_step,
        'total_steps': len(workflow),
        'step_description': workflow[current_step - 1],
        'current_agent': current_agent
    })

# Create tasks


def create_tasks(job_id):
    return [
        Task(
            description="Define research scope, objectives, and methodology",
            agent=dr_amelia_reeves,
            expected_output="Detailed research plan including research questions, methodology, and timeline",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Conduct literature review and gather secondary research",
            agent=zara_chen,
            expected_output="Comprehensive literature review document with key findings and sources",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Design and conduct primary research (surveys, interviews, etc.)",
            agent=lucas_ortiz,
            expected_output="Raw data from primary research activities in structured format (e.g., CSV, JSON)",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Analyze primary data and extract key insights",
            agent=lucas_ortiz,
            expected_output="Analysis report with statistical findings and qualitative insights",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Synthesize findings from primary and secondary research",
            agent=oliver_nkosi,
            expected_output="Comprehensive synthesis document highlighting main findings and their implications",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Create data visualizations for key findings",
            agent=emma_dubois,
            expected_output="Set of charts, graphs, and infographics illustrating main research results",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Develop report outline and structure",
            agent=sophia_larsson,
            expected_output="Detailed report outline with sections and subsections",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Write first draft of the report",
            agent=sophia_larsson,
            expected_output="First draft of the full research report in markdown format",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Review report for scientific rigor and accuracy",
            agent=dr_rajesh_patel,
            expected_output="Reviewed document with suggestions for improvements and corrections",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Incorporate feedback and refine report",
            agent=sophia_larsson,
            expected_output="Revised draft of the research report",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Design final report layout and integrate visualizations",
            agent=emma_dubois,
            expected_output="Formatted report with integrated graphics and consistent design",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Conduct final review and proofreading",
            agent=dr_amelia_reeves,
            expected_output="Final, polished research report ready for submission",
            callback=lambda output: step_callback(job_id, output)
        )
    ]


def get_agent_for_step(step):
    step_agent_map = {
        1: "Dr. Amelia Reeves",
        2: "Zara Chen",
        3: "Lucas Ortiz",
        4: "Lucas Ortiz",
        5: "Oliver Nkosi",
        6: "Emma Dubois",
        7: "Sophia Larsson",
        8: "Sophia Larsson",
        9: "Dr. Rajesh Patel",
        10: "Sophia Larsson",
        11: "Emma Dubois",
        12: "Dr. Amelia Reeves"
    }
    return step_agent_map.get(step, "Unknown Agent")


def run_task(job_id, task_index):
    task = research_jobs[job_id]['tasks'][task_index]
    crew = Crew(
        agents=[dr_amelia_reeves, lucas_ortiz, zara_chen, oliver_nkosi,
                sophia_larsson, dr_rajesh_patel, emma_dubois],
        tasks=[task],
        process=Process.sequential
    )
    result = crew.kickoff()
    research_jobs[job_id]['current_step'] = task_index + 1
    research_jobs[job_id]['tasks'][task_index]['status'] = 'completed'
    research_jobs[job_id]['tasks'][task_index]['result'] = result
    return result


@app.route('/')
def serve_index():
    return send_from_directory('.', 'index.html')


@app.route('/api/research', methods=['POST'])
def start_research():
    topic = request.json['topic']
    job_id = str(uuid.uuid4())
    tasks = create_tasks(job_id)
    research_jobs[job_id] = {
        'status': 'pending',
        'topic': topic,
        'current_step': 0,
        'tasks': [{'status': 'pending', 'result': None} for _ in tasks]
    }
    return jsonify({'job_id': job_id}), 202


@app.route('/api/research/<job_id>/status', methods=['GET'])
def get_research_status(job_id):
    job = research_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    return jsonify({
        'status': job['status'],
        'current_step': job.get('current_step', 0),
        'total_steps': len(workflow),
        'current_agent': job.get('current_agent'),
        'tasks': job['tasks']
    })


@app.route('/api/research/<job_id>/task/<int:task_index>', methods=['POST'])
def execute_task(job_id, task_index):
    job = research_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    if task_index < 0 or task_index >= len(job['tasks']):
        return jsonify({'error': 'Invalid task index'}), 400
    if job['tasks'][task_index]['status'] == 'completed':
        return jsonify({'error': 'Task already completed'}), 400

    Thread(target=run_task, args=(job_id, task_index)).start()
    return jsonify({'message': 'Task execution started'}), 202


@app.route('/api/research/<job_id>/results', methods=['GET'])
def get_research_results(job_id):
    job = research_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    return jsonify({'results': job['tasks']})


@app.route('/api/agents', methods=['GET'])
def get_agents():
    return jsonify(agents)


@app.route('/api/workflow', methods=['GET'])
def get_workflow():
    return jsonify(workflow)


if __name__ == '__main__':
    socketio.run(app, host='localhost', port=5901, debug=True)

</code_example>


=== Reply 0 ===
Certainly! I'll modify the code example to implement the agents and tasks design we created earlier. Here's the updated Python code:

<SERVER_PYTHON_CODE>
import os
import uuid
from threading import Thread

from crewai import Agent, Crew, Process, Task
from dotenv import load_dotenv
from flask import Flask, jsonify, request, send_from_directory
from flask_cors import CORS
from flask_socketio import SocketIO
from langchain_anthropic import ChatAnthropic
from langchain_community.tools import DuckDuckGoSearchRun
from langchain_core.agents import AgentFinish
from crewai_tools import ScrapeWebsiteTool, SerperDevTool

# Assume ANTHROPIC_API_KEY and other keys have been set in .env file.
load_dotenv()

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

# Set up the language model
model = 'claude-3-haiku-20240307'
llm = ChatAnthropic(model=model, temperature=0.2)

# Initialize tools
duck_tool = DuckDuckGoSearchRun()
search_tool = SerperDevTool()
scrape_tool = ScrapeWebsiteTool()

# Create agents
alex_dataminer = Agent(
    role='Data Miner',
    goal='Gather and analyze data on recent YC accepted applications',
    backstory='Former data scientist at a top tech company, Alex specializes in collecting and analyzing large datasets. They have a keen eye for patterns and trends in startup ecosystems.',
    tools=[search_tool, scrape_tool],
    llm=llm
)

samantha_ycinsider = Agent(
    role='YC Insider',
    goal='Provide insights on YC selection criteria and preferences',
    backstory='Ex-YC partner with years of experience in evaluating startup applications. Samantha has a deep understanding of what YC looks for in potential investments.',
    tools=[search_tool],
    llm=llm
)

marcus_trendspotter = Agent(
    role='Trend Spotter',
    goal='Identify current market trends and emerging technologies',
    backstory='Tech journalist turned market analyst, Marcus has a finger on the pulse of the startup world. He excels at identifying upcoming trends and assessing their potential impact.',
    tools=[search_tool, duck_tool],
    llm=llm
)

olivia_pitchperfector = Agent(
    role='Pitch Perfector',
    goal='Analyze and improve pitch strategies',
    backstory='Startup pitch coach with a track record of helping founders secure funding. Olivia has a talent for crafting compelling narratives and identifying key selling points.',
    tools=[search_tool],
    llm=llm
)

ryan_companalyst = Agent(
    role='Competitive Analyst',
    goal='Conduct competitive analysis and market positioning',
    backstory='Former strategy consultant specializing in startup ecosystems. Ryan excels at mapping out competitive landscapes and identifying unique value propositions.',
    tools=[search_tool, scrape_tool],
    llm=llm
)

emily_techevaluator = Agent(
    role='Tech Evaluator',
    goal='Assess technical feasibility and innovation of ideas',
    backstory='Software engineer with experience in multiple startups. Emily has a broad understanding of various technologies and can evaluate the technical merit of startup ideas.',
    tools=[search_tool],
    llm=llm
)

david_synthesisguru = Agent(
    role='Synthesis Guru',
    goal='Synthesize information and generate final evaluation report',
    backstory='Experienced business writer and analyst, David has a talent for integrating diverse information into coherent, actionable reports. He ensures all aspects of the evaluation are considered and well-presented.',
    tools=[search_tool],
    llm=llm
)

# In-memory storage for simplicity
evaluation_jobs = {}

agents = [
    {"name": "Alex DataMiner", "role": "Data Miner"},
    {"name": "Samantha YCInsider", "role": "YC Insider"},
    {"name": "Marcus TrendSpotter", "role": "Trend Spotter"},
    {"name": "Olivia PitchPerfector", "role": "Pitch Perfector"},
    {"name": "Ryan CompAnalyst", "role": "Competitive Analyst"},
    {"name": "Emily TechEvaluator", "role": "Tech Evaluator"},
    {"name": "David SynthesisGuru", "role": "Synthesis Guru"}
]

workflow = [
    "Gather and analyze data on recent YC accepted applications",
    "Identify current YC selection criteria and preferences",
    "Analyze current market trends and emerging technologies",
    "Evaluate the given idea against YC criteria and market trends",
    "Assess technical feasibility and innovation of the idea",
    "Analyze and suggest improvements for the idea's pitch strategy",
    "Conduct competitive analysis and market positioning",
    "Synthesize all gathered information and generate final evaluation report"
]

# Step callback function
def step_callback(job_id, step_output):
    if isinstance(step_output, AgentFinish):
        status = "completed"
        result = step_output.return_values.get('output', '')
    else:
        status = "in_progress"
        result = str(step_output)

    current_step = evaluation_jobs[job_id].get('current_step', 0)
    current_agent = get_agent_for_step(current_step)

    evaluation_jobs[job_id]['current_step'] = current_step
    evaluation_jobs[job_id]['current_agent'] = current_agent
    evaluation_jobs[job_id]['tasks'][current_step - 1]['status'] = status
    evaluation_jobs[job_id]['tasks'][current_step - 1]['result'] = result

    socketio.emit('evaluation_update', {
        'job_id': job_id,
        'status': status,
        'result': result,
        'current_step': current_step,
        'total_steps': len(workflow),
        'step_description': workflow[current_step - 1],
        'current_agent': current_agent
    })

# Create tasks
def create_tasks(job_id):
    return [
        Task(
            description="Gather and analyze data on recent YC accepted applications",
            agent=alex_dataminer,
            expected_output="JSON document containing detailed information on recent YC accepted startups, including industry, funding, team composition, and key metrics",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Identify current YC selection criteria and preferences",
            agent=samantha_ycinsider,
            expected_output="Report outlining YC's current selection criteria, preferences, and any recent shifts in investment focus",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Analyze current market trends and emerging technologies",
            agent=marcus_trendspotter,
            expected_output="List of top market trends and emerging technologies relevant to YC's interests, with supporting data",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Evaluate the given idea against YC criteria and market trends",
            agent=ryan_companalyst,
            expected_output="Initial assessment report comparing the given idea to YC criteria and current market trends",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Assess technical feasibility and innovation of the idea",
            agent=emily_techevaluator,
            expected_output="Technical evaluation report detailing the idea's feasibility, innovativeness, and potential technical challenges",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Analyze and suggest improvements for the idea's pitch strategy",
            agent=olivia_pitchperfector,
            expected_output="Pitch analysis report with specific recommendations for improvement",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Conduct competitive analysis and market positioning",
            agent=ryan_companalyst,
            expected_output="Competitive landscape report and suggested market positioning strategy",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Synthesize all gathered information and generate final evaluation report",
            agent=david_synthesisguru,
            expected_output="Comprehensive evaluation report assessing the idea's chances of YC acceptance, including strengths, weaknesses, and recommendations",
            callback=lambda output: step_callback(job_id, output)
        )
    ]

def get_agent_for_step(step):
    step_agent_map = {
        1: "Alex DataMiner",
        2: "Samantha YCInsider",
        3: "Marcus TrendSpotter",
        4: "Ryan CompAnalyst",
        5: "Emily TechEvaluator",
        6: "Olivia PitchPerfector",
        7: "Ryan CompAnalyst",
        8: "David SynthesisGuru"
    }
    return step_agent_map.get(step, "Unknown Agent")

def run_task(job_id, task_index):
    task = evaluation_jobs[job_id]['tasks'][task_index]
    crew = Crew(
        agents=[alex_dataminer, samantha_ycinsider, marcus_trendspotter, olivia_pitchperfector,
                ryan_companalyst, emily_techevaluator, david_synthesisguru],
        tasks=[task],
        process=Process.sequential
    )
    result = crew.kickoff()
    evaluation_jobs[job_id]['current_step'] = task_index + 1
    evaluation_jobs[job_id]['tasks'][task_index]['status'] = 'completed'
    evaluation_jobs[job_id]['tasks'][task_index]['result'] = result
    return result

@app.route('/')
def serve_index():
    return send_from_directory('.', 'index.html')

@app.route('/api/evaluate', methods=['POST'])
def start_evaluation():
    idea = request.json['idea']
    job_id = str(uuid.uuid4())
    tasks = create_tasks(job_id)
    evaluation_jobs[job_id] = {
        'status': 'pending',
        'idea': idea,
        'current_step': 0,
        'tasks': [{'status': 'pending', 'result': None} for _ in tasks]
    }
    return jsonify({'job_id': job_id}), 202

@app.route('/api/evaluate/<job_id>/status', methods=['GET'])
def get_evaluation_status(job_id):
    job = evaluation_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    return jsonify({
        'status': job['status'],
        'current_step': job.get('current_step', 0),
        'total_steps': len(workflow),
        'current_agent': job.get('current_agent'),
        'tasks': job['tasks']
    })

@app.route('/api/evaluate/<job_id>/task/<int:task_index>', methods=['POST'])
def execute_task(job_id, task_index):
    job = evaluation_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    if task_index < 0 or task_index >= len(job['tasks']):
        return jsonify({'error': 'Invalid task index'}), 400
    if job['tasks'][task_index]['status'] == 'completed':
        return jsonify({'error': 'Task already completed'}), 400

    Thread(target=run_task, args=(job_id, task_index)).start()
    return jsonify({'message': 'Task execution started'}), 202

@app.route('/api/evaluate/<job_id>/results', methods=['GET'])
def get_evaluation_results(job_id):
    job = evaluation_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    return jsonify({'results': job['tasks']})

@app.route('/api/agents', methods=['GET'])
def get_agents():
    return jsonify(agents)

@app.route('/api/workflow', methods=['GET'])
def get_workflow():
    return jsonify(workflow)

if __name__ == '__main__':
    socketio.run(app, host='localhost', port=7457, debug=True)
</SERVER_PYTHON_CODE>

This implementation adapts the original code to our specific YC application evaluation task. Here are the key changes:

1. Updated the agents to match our design (Alex DataMiner, Samantha YCInsider, etc.).
2. Modified the workflow steps to align with our task design.
3. Updated the `create_tasks` function to create tasks based on our workflow.
4. Changed the `get_agent_for_step` function to map steps to our new agents.
5. Updated the API endpoints to use "evaluate" instead of "research" to better reflect the task.
6. Modified the input to accept an "idea" instead of a "topic".
7. Changed the port to 7457 as requested.

The core functionality remains the same:
- Users can submit an idea for evaluation.
- The system will process the idea through a series of tasks, each handled by a specialized agent.
- Users can check the status of the evaluation and retrieve results.
- The system provides real-time updates via WebSocket.

This implementation should provide a solid foundation for evaluating startup ideas against YC's criteria and current trends. You may need to further customize the agents' behaviors and the specific details of each task to fully match your requirements.