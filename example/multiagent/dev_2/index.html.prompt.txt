claude-3-5-sonnet-20240620

You are an expert in Web development, including CSS, JavaScript, React, Tailwind, Node.JS and Hugo / Markdown. You are expert at selecting and choosing the best tools, and doing your utmost to avoid unnecessary duplication and complexity.
When making a suggestion, you break things down in to discrete changes, and suggest a small test after each stage to make sure things are on the right track.
Produce code to illustrate examples, or when directed to in the conversation. If you can answer without code, that is preferred, and you will be asked to elaborate if it is required.
Before writing or suggesting code, you conduct a deep-dive review of the existing code and describe how it works between <CODE_REVIEW> tags. Once you have completed the review, you produce a careful plan for the change in <PLANNING> tags. Pay attention to variable names and string literals - when reproducing code make sure that these do not change unless necessary or directed. If naming something by convention surround in double colons and in ::UPPERCASE::.
Finally, you produce correct outputs that provide the right balance between solving the immediate problem and remaining generic and flexible.
You always ask for clarifications if anything is unclear or ambiguous. You stop to discuss trade-offs and implementation options if there are choices to make.
It is important that you follow this approach, and do your best to teach your interlocutor about making effective decisions. You avoid apologising unnecessarily, and review the conversation to never repeat earlier mistakes.
You are keenly aware of security, and make sure at every step that we don't do anything that could compromise data or introduce new vulnerabilities. Whenever there is a potential security risk (e.g. input handling, authentication management) you will do an additional review, showing your reasoning between <SECURITY_REVIEW> tags.
Finally, it is important that everything produced is operationally sound. We consider how to host, manage, monitor and maintain our solutions. You consider operational concerns at every step, and highlight them where they are relevant.
Bonus: if you can use 3djs or WebGL anywhere need a render or dashboard, use it.  

Assume the server is already running at `localhost:7457`, generate html code that connects to the server.  

Final html code should be included in <INDEX_HTML_CODE></INDEX_HTML_CODE> block.


=== 0: user ===
<PROBLEM>
Create agents help me to evaluate a given idea how much chance to be accepted by YC.
Investigate recent accepted applications in recent batchs.
Do thorough analysis why they be accepted and evaluate ours.
</PROBLEM>

Design a list of agents, output in JSON format and put in <AGENTS_DESIGN></AGENTS_DESIGN> block.
(content in <AGENTS_DESIGN> will create file and written to "agents_design.json")

E.g.
```
<AGENTS_DESIGN>
[
  {
    "name": "Olivia Thompson",
    "goal": "Gather and analyze market data",
    "backstory": "Experienced market analyst with a keen eye for trends and patterns. Olivia has worked in various industries and excels at turning raw data into actionable insights.",
    "tools": ["search_tool", "scrape_tool", "duckduck_tool"]
  },
  {
    "name": "Marcus Chen",
    "goal": "Identify target audience and competitors",
    "backstory": "Former marketing strategist turned consultant. Marcus specializes in customer segmentation and competitive analysis, with a track record of helping startups position themselves effectively.",
    "tools": ["search_tool", "scrape_tool", "duckduck_tool"]
  },
  {
    "name": "Sophia Patel",
    "goal": "Synthesize information and craft compelling narratives",
    "backstory": "Skilled content writer and editor with a background in business journalism. Sophia has a talent for distilling complex information into clear, engaging prose.",
    "tools": ["search_tool", "scrape_tool", "duckduck_tool"]
  },
  {
    "name": "Ethan Novak",
    "goal": "Ensure accuracy and coherence of the final document",
    "backstory": "Meticulous proofreader and fact-checker with experience in academic publishing. Ethan has a broad knowledge base and a knack for spotting inconsistencies and gaps in information.",
    "tools": ["search_tool", "scrape_tool", "duckduck_tool"]
  }
]
</AGENTS_DESIGN>
```

=== 1: assistant ===
Certainly! I'll design a multi-agent system to evaluate an idea's chances of being accepted by Y Combinator (YC) and analyze recent accepted applications. Here's the JSON format of the agents designed for this task:

<AGENTS_DESIGN>
[
  {
    "name": "Alex DataMiner",
    "goal": "Gather and analyze data on recent YC accepted applications",
    "backstory": "Former data scientist at a top tech company, Alex specializes in collecting and analyzing large datasets. They have a keen eye for patterns and trends in startup ecosystems.",
    "tools": ["search_tool", "scrape_tool", "data_analysis_tool"]
  },
  {
    "name": "Samantha YCInsider",
    "goal": "Provide insights on YC selection criteria and preferences",
    "backstory": "Ex-YC partner with years of experience in evaluating startup applications. Samantha has a deep understanding of what YC looks for in potential investments.",
    "tools": ["search_tool", "yc_database_tool"]
  },
  {
    "name": "Marcus TrendSpotter",
    "goal": "Identify current market trends and emerging technologies",
    "backstory": "Tech journalist turned market analyst, Marcus has a finger on the pulse of the startup world. He excels at identifying upcoming trends and assessing their potential impact.",
    "tools": ["search_tool", "news_aggregator_tool", "social_media_analysis_tool"]
  },
  {
    "name": "Olivia PitchPerfector",
    "goal": "Analyze and improve pitch strategies",
    "backstory": "Startup pitch coach with a track record of helping founders secure funding. Olivia has a talent for crafting compelling narratives and identifying key selling points.",
    "tools": ["search_tool", "language_analysis_tool"]
  },
  {
    "name": "Ryan CompAnalyst",
    "goal": "Conduct competitive analysis and market positioning",
    "backstory": "Former strategy consultant specializing in startup ecosystems. Ryan excels at mapping out competitive landscapes and identifying unique value propositions.",
    "tools": ["search_tool", "market_analysis_tool", "competitor_tracking_tool"]
  },
  {
    "name": "Emily TechEvaluator",
    "goal": "Assess technical feasibility and innovation of ideas",
    "backstory": "Software engineer with experience in multiple startups. Emily has a broad understanding of various technologies and can evaluate the technical merit of startup ideas.",
    "tools": ["search_tool", "code_analysis_tool", "tech_stack_evaluator_tool"]
  },
  {
    "name": "David SynthesisGuru",
    "goal": "Synthesize information and generate final evaluation report",
    "backstory": "Experienced business writer and analyst, David has a talent for integrating diverse information into coherent, actionable reports. He ensures all aspects of the evaluation are considered and well-presented.",
    "tools": ["search_tool", "document_creation_tool", "data_visualization_tool"]
  }
]
</AGENTS_DESIGN>

This multi-agent system is designed to comprehensively evaluate an idea's chances of being accepted by YC by analyzing recent accepted applications and conducting a thorough analysis. Each agent has a specific role and set of skills to contribute to the overall evaluation process.
=== 2: user ===

Using these agents, think about a linear workflow to finish the task, each step has a "description", "agent" and "expected_output", the step output will be passing to the next step.
Output in JSON format and put in <TASKS_DESIGN></TASKS_DESIGN> block.
(content in <TASKS_DESIGN> will create file and written to "tasks_design.json")

E.g.
```
<TASKS_DESIGN>
[
  {
    "step": 1,
    "description": "Gather relevant market data and statistics",
    "expected_output": "Compiled market data in JSON format, including market size, growth rate, and key trends",
    "agent": "Olivia Thompson",
  },
  {
    "step": 2,
    "description": "Analyze target audience and identify main competitors",
    "expected_output": "JSON document containing target audience segments and a list of top competitors with their market shares",
    "agent": "Marcus Chen"
  },
  {
    "step": 3,
    "description": "Analyze gathered data and extract key insights",
    "expected_output": "List of key insights and their implications for the market",
    "agent": "Olivia Thompson"
  },
  {
    "step": 4,
    "description": "Create an outline for the 1-pager based on gathered information",
    "expected_output": "Detailed outline of the 1-pager in markdown format",
    "agent": "Sophia Patel"
  },
  {
    "step": 5,
    "description": "Write the first draft of the market research 1-pager",
    "expected_output": "First draft of the 1-pager in markdown format",
    "agent": "Sophia Patel"
  },
  {
    "step": 6,
    "description": "Review and fact-check the first draft",
    "expected_output": "Reviewed document with suggestions for improvements and corrections",
    "agent": "Ethan Novak"
  },
  {
    "step": 7,
    "description": "Incorporate feedback and finalize the 1-pager",
    "expected_output": "Final version of the market research 1-pager in markdown format",
    "agent": "Sophia Patel"
  },
  {
    "step": 8,
    "description": "Perform final proofreading and quality check",
    "expected_output": "Proofread and approved market research 1-pager, ready for presentation",
    "agent": "Ethan Novak"
  }
]
</TASKS_DESIGN>
```

=== 3: assistant ===
Certainly! I'll create a linear workflow using the agents we've designed to evaluate an idea's chances of being accepted by YC. Here's the JSON format of the tasks designed for this process:

<TASKS_DESIGN>
[
  {
    "step": 1,
    "description": "Gather and analyze data on recent YC accepted applications",
    "expected_output": "JSON document containing detailed information on recent YC accepted startups, including industry, funding, team composition, and key metrics",
    "agent": "Alex DataMiner"
  },
  {
    "step": 2,
    "description": "Identify current YC selection criteria and preferences",
    "expected_output": "Report outlining YC's current selection criteria, preferences, and any recent shifts in investment focus",
    "agent": "Samantha YCInsider"
  },
  {
    "step": 3,
    "description": "Analyze current market trends and emerging technologies",
    "expected_output": "List of top market trends and emerging technologies relevant to YC's interests, with supporting data",
    "agent": "Marcus TrendSpotter"
  },
  {
    "step": 4,
    "description": "Evaluate the given idea against YC criteria and market trends",
    "expected_output": "Initial assessment report comparing the given idea to YC criteria and current market trends",
    "agent": "Ryan CompAnalyst"
  },
  {
    "step": 5,
    "description": "Assess technical feasibility and innovation of the idea",
    "expected_output": "Technical evaluation report detailing the idea's feasibility, innovativeness, and potential technical challenges",
    "agent": "Emily TechEvaluator"
  },
  {
    "step": 6,
    "description": "Analyze and suggest improvements for the idea's pitch strategy",
    "expected_output": "Pitch analysis report with specific recommendations for improvement",
    "agent": "Olivia PitchPerfector"
  },
  {
    "step": 7,
    "description": "Conduct competitive analysis and market positioning",
    "expected_output": "Competitive landscape report and suggested market positioning strategy",
    "agent": "Ryan CompAnalyst"
  },
  {
    "step": 8,
    "description": "Synthesize all gathered information and generate final evaluation report",
    "expected_output": "Comprehensive evaluation report assessing the idea's chances of YC acceptance, including strengths, weaknesses, and recommendations",
    "agent": "David SynthesisGuru"
  }
]
</TASKS_DESIGN>

This workflow is designed to systematically evaluate the given idea's chances of being accepted by YC. It starts with gathering data on recent YC acceptances and understanding YC's current preferences, then moves on to analyzing market trends and the specific idea. The process includes technical evaluation, pitch analysis, and competitive positioning before culminating in a comprehensive final report. Each step builds on the previous ones, with the output of each task serving as input for the next, ensuring a thorough and well-rounded evaluation.
=== 4: user ===
Implement the agents/tasks design based on modifying this code example.

<code_example>
import os
import uuid
from threading import Thread

from crewai import Agent, Crew, Process, Task
from dotenv import load_dotenv
from flask import Flask, jsonify, request, send_from_directory
from flask_cors import CORS
from flask_socketio import SocketIO
from langchain_anthropic import ChatAnthropic
from langchain_community.tools import DuckDuckGoSearchRun
from langchain_core.agents import AgentFinish
from crewai_tools import ScrapeWebsiteTool, SerperDevTool

# Assume ANTHROPIC_API_KEY and other keys have been set in .env file.
load_dotenv()

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

# Set up the language model
model = 'claude-3-haiku-20240307'
llm = ChatAnthropic(model=model, temperature=0.2)

# Initialize tools
duck_tool = DuckDuckGoSearchRun()
search_tool = SerperDevTool()
scrape_tool = ScrapeWebsiteTool()

# Create agents
dr_amelia_reeves = Agent(
    role='Research Director',
    goal='Define research scope and methodology',
    backstory='Experienced research director with a Ph.D. in Information Science. Amelia excels at designing comprehensive research plans and ensuring projects stay on track.',
    tools=[search_tool, duck_tool],
    llm=llm
)

lucas_ortiz = Agent(
    role='Data Scientist',
    goal='Gather and analyze primary data',
    backstory='Skilled data scientist with expertise in both quantitative and qualitative research methods. Lucas has a talent for uncovering insights from complex datasets and conducting in-depth interviews.',
    tools=[search_tool, scrape_tool],
    llm=llm
)

zara_chen = Agent(
    role='Research Analyst',
    goal='Conduct literature review and secondary research',
    backstory='Librarian turned research analyst with a knack for finding and synthesizing information from diverse sources. Zara is adept at using various databases and academic resources.',
    tools=[search_tool, scrape_tool, duck_tool],
    llm=llm
)

oliver_nkosi = Agent(
    role='Insights Specialist',
    goal='Interpret findings and develop key insights',
    backstory='Former management consultant with a background in strategy. Oliver specializes in connecting dots between different pieces of information and identifying actionable insights.',
    tools=[search_tool, scrape_tool, duck_tool],
    llm=llm
)

sophia_larsson = Agent(
    role='Technical Writer',
    goal='Write and structure the report',
    backstory='Experienced technical writer with a background in journalism. Sophia excels at organizing complex information into clear, logical structures and writing engaging, accessible prose.',
    tools=[search_tool, scrape_tool, duck_tool],
    llm=llm
)

dr_rajesh_patel = Agent(
    role='Scientific Reviewer',
    goal='Ensure scientific rigor and accuracy',
    backstory='Academic researcher and peer reviewer with expertise in multiple fields. Rajesh has a keen eye for methodological issues and ensures all claims are properly supported by evidence.',
    tools=[search_tool, scrape_tool, duck_tool],
    llm=llm
)

emma_dubois = Agent(
    role='Data Visualization Specialist',
    goal='Create data visualizations and design report layout',
    backstory='Graphic designer specializing in data visualization and report design. Emma has a talent for presenting complex information in visually appealing and easily digestible formats.',
    tools=[search_tool, scrape_tool, duck_tool],
    llm=llm
)

# In-memory storage for simplicity
research_jobs = {}

agents = [
    {"name": "Dr. Amelia Reeves", "role": "Research Director"},
    {"name": "Lucas Ortiz", "role": "Data Scientist"},
    {"name": "Zara Chen", "role": "Research Analyst"},
    {"name": "Oliver Nkosi", "role": "Insights Specialist"},
    {"name": "Sophia Larsson", "role": "Technical Writer"},
    {"name": "Dr. Rajesh Patel", "role": "Scientific Reviewer"},
    {"name": "Emma Dubois", "role": "Data Visualization Specialist"}
]

workflow = [
    "Define research scope",
    "Conduct literature review",
    "Design and conduct primary research",
    "Analyze primary data",
    "Synthesize findings",
    "Create data visualizations",
    "Develop report outline",
    "Write first draft",
    "Review for scientific rigor",
    "Incorporate feedback",
    "Design final layout",
    "Conduct final review"
]

# Step callback function


def step_callback(job_id, step_output):
    if isinstance(step_output, AgentFinish):
        status = "completed"
        result = step_output.return_values.get('output', '')
    else:
        status = "in_progress"
        result = str(step_output)

    current_step = research_jobs[job_id].get('current_step', 0)
    current_agent = get_agent_for_step(current_step)

    research_jobs[job_id]['current_step'] = current_step
    research_jobs[job_id]['current_agent'] = current_agent
    research_jobs[job_id]['tasks'][current_step - 1]['status'] = status
    research_jobs[job_id]['tasks'][current_step - 1]['result'] = result

    socketio.emit('research_update', {
        'job_id': job_id,
        'status': status,
        'result': result,
        'current_step': current_step,
        'total_steps': len(workflow),
        'step_description': workflow[current_step - 1],
        'current_agent': current_agent
    })

# Create tasks


def create_tasks(job_id):
    return [
        Task(
            description="Define research scope, objectives, and methodology",
            agent=dr_amelia_reeves,
            expected_output="Detailed research plan including research questions, methodology, and timeline",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Conduct literature review and gather secondary research",
            agent=zara_chen,
            expected_output="Comprehensive literature review document with key findings and sources",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Design and conduct primary research (surveys, interviews, etc.)",
            agent=lucas_ortiz,
            expected_output="Raw data from primary research activities in structured format (e.g., CSV, JSON)",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Analyze primary data and extract key insights",
            agent=lucas_ortiz,
            expected_output="Analysis report with statistical findings and qualitative insights",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Synthesize findings from primary and secondary research",
            agent=oliver_nkosi,
            expected_output="Comprehensive synthesis document highlighting main findings and their implications",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Create data visualizations for key findings",
            agent=emma_dubois,
            expected_output="Set of charts, graphs, and infographics illustrating main research results",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Develop report outline and structure",
            agent=sophia_larsson,
            expected_output="Detailed report outline with sections and subsections",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Write first draft of the report",
            agent=sophia_larsson,
            expected_output="First draft of the full research report in markdown format",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Review report for scientific rigor and accuracy",
            agent=dr_rajesh_patel,
            expected_output="Reviewed document with suggestions for improvements and corrections",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Incorporate feedback and refine report",
            agent=sophia_larsson,
            expected_output="Revised draft of the research report",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Design final report layout and integrate visualizations",
            agent=emma_dubois,
            expected_output="Formatted report with integrated graphics and consistent design",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Conduct final review and proofreading",
            agent=dr_amelia_reeves,
            expected_output="Final, polished research report ready for submission",
            callback=lambda output: step_callback(job_id, output)
        )
    ]


def get_agent_for_step(step):
    step_agent_map = {
        1: "Dr. Amelia Reeves",
        2: "Zara Chen",
        3: "Lucas Ortiz",
        4: "Lucas Ortiz",
        5: "Oliver Nkosi",
        6: "Emma Dubois",
        7: "Sophia Larsson",
        8: "Sophia Larsson",
        9: "Dr. Rajesh Patel",
        10: "Sophia Larsson",
        11: "Emma Dubois",
        12: "Dr. Amelia Reeves"
    }
    return step_agent_map.get(step, "Unknown Agent")


def run_task(job_id, task_index):
    task = research_jobs[job_id]['tasks'][task_index]
    crew = Crew(
        agents=[dr_amelia_reeves, lucas_ortiz, zara_chen, oliver_nkosi,
                sophia_larsson, dr_rajesh_patel, emma_dubois],
        tasks=[task],
        process=Process.sequential
    )
    result = crew.kickoff()
    research_jobs[job_id]['current_step'] = task_index + 1
    research_jobs[job_id]['tasks'][task_index]['status'] = 'completed'
    research_jobs[job_id]['tasks'][task_index]['result'] = result
    return result


@app.route('/')
def serve_index():
    return send_from_directory('.', 'index.html')


@app.route('/api/research', methods=['POST'])
def start_research():
    topic = request.json['topic']
    job_id = str(uuid.uuid4())
    tasks = create_tasks(job_id)
    research_jobs[job_id] = {
        'status': 'pending',
        'topic': topic,
        'current_step': 0,
        'tasks': [{'status': 'pending', 'result': None} for _ in tasks]
    }
    return jsonify({'job_id': job_id}), 202


@app.route('/api/research/<job_id>/status', methods=['GET'])
def get_research_status(job_id):
    job = research_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    return jsonify({
        'status': job['status'],
        'current_step': job.get('current_step', 0),
        'total_steps': len(workflow),
        'current_agent': job.get('current_agent'),
        'tasks': job['tasks']
    })


@app.route('/api/research/<job_id>/task/<int:task_index>', methods=['POST'])
def execute_task(job_id, task_index):
    job = research_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    if task_index < 0 or task_index >= len(job['tasks']):
        return jsonify({'error': 'Invalid task index'}), 400
    if job['tasks'][task_index]['status'] == 'completed':
        return jsonify({'error': 'Task already completed'}), 400

    Thread(target=run_task, args=(job_id, task_index)).start()
    return jsonify({'message': 'Task execution started'}), 202


@app.route('/api/research/<job_id>/results', methods=['GET'])
def get_research_results(job_id):
    job = research_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    return jsonify({'results': job['tasks']})


@app.route('/api/agents', methods=['GET'])
def get_agents():
    return jsonify(agents)


@app.route('/api/workflow', methods=['GET'])
def get_workflow():
    return jsonify(workflow)


if __name__ == '__main__':
    socketio.run(app, host='localhost', port=5901, debug=True)

</code_example>

=== 5: assistant ===
Certainly! I'll modify the code example to implement the agents and tasks design we created earlier. Here's the updated Python code:

<SERVER_PYTHON_CODE>
import os
import uuid
from threading import Thread

from crewai import Agent, Crew, Process, Task
from dotenv import load_dotenv
from flask import Flask, jsonify, request, send_from_directory
from flask_cors import CORS
from flask_socketio import SocketIO
from langchain_anthropic import ChatAnthropic
from langchain_community.tools import DuckDuckGoSearchRun
from langchain_core.agents import AgentFinish
from crewai_tools import ScrapeWebsiteTool, SerperDevTool

# Assume ANTHROPIC_API_KEY and other keys have been set in .env file.
load_dotenv()

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

# Set up the language model
model = 'claude-3-haiku-20240307'
llm = ChatAnthropic(model=model, temperature=0.2)

# Initialize tools
duck_tool = DuckDuckGoSearchRun()
search_tool = SerperDevTool()
scrape_tool = ScrapeWebsiteTool()

# Create agents
alex_dataminer = Agent(
    role='Data Miner',
    goal='Gather and analyze data on recent YC accepted applications',
    backstory='Former data scientist at a top tech company, Alex specializes in collecting and analyzing large datasets. They have a keen eye for patterns and trends in startup ecosystems.',
    tools=[search_tool, scrape_tool],
    llm=llm
)

samantha_ycinsider = Agent(
    role='YC Insider',
    goal='Provide insights on YC selection criteria and preferences',
    backstory='Ex-YC partner with years of experience in evaluating startup applications. Samantha has a deep understanding of what YC looks for in potential investments.',
    tools=[search_tool],
    llm=llm
)

marcus_trendspotter = Agent(
    role='Trend Spotter',
    goal='Identify current market trends and emerging technologies',
    backstory='Tech journalist turned market analyst, Marcus has a finger on the pulse of the startup world. He excels at identifying upcoming trends and assessing their potential impact.',
    tools=[search_tool, duck_tool],
    llm=llm
)

olivia_pitchperfector = Agent(
    role='Pitch Perfector',
    goal='Analyze and improve pitch strategies',
    backstory='Startup pitch coach with a track record of helping founders secure funding. Olivia has a talent for crafting compelling narratives and identifying key selling points.',
    tools=[search_tool],
    llm=llm
)

ryan_companalyst = Agent(
    role='Competitive Analyst',
    goal='Conduct competitive analysis and market positioning',
    backstory='Former strategy consultant specializing in startup ecosystems. Ryan excels at mapping out competitive landscapes and identifying unique value propositions.',
    tools=[search_tool, scrape_tool],
    llm=llm
)

emily_techevaluator = Agent(
    role='Tech Evaluator',
    goal='Assess technical feasibility and innovation of ideas',
    backstory='Software engineer with experience in multiple startups. Emily has a broad understanding of various technologies and can evaluate the technical merit of startup ideas.',
    tools=[search_tool],
    llm=llm
)

david_synthesisguru = Agent(
    role='Synthesis Guru',
    goal='Synthesize information and generate final evaluation report',
    backstory='Experienced business writer and analyst, David has a talent for integrating diverse information into coherent, actionable reports. He ensures all aspects of the evaluation are considered and well-presented.',
    tools=[search_tool],
    llm=llm
)

# In-memory storage for simplicity
evaluation_jobs = {}

agents = [
    {"name": "Alex DataMiner", "role": "Data Miner"},
    {"name": "Samantha YCInsider", "role": "YC Insider"},
    {"name": "Marcus TrendSpotter", "role": "Trend Spotter"},
    {"name": "Olivia PitchPerfector", "role": "Pitch Perfector"},
    {"name": "Ryan CompAnalyst", "role": "Competitive Analyst"},
    {"name": "Emily TechEvaluator", "role": "Tech Evaluator"},
    {"name": "David SynthesisGuru", "role": "Synthesis Guru"}
]

workflow = [
    "Gather and analyze data on recent YC accepted applications",
    "Identify current YC selection criteria and preferences",
    "Analyze current market trends and emerging technologies",
    "Evaluate the given idea against YC criteria and market trends",
    "Assess technical feasibility and innovation of the idea",
    "Analyze and suggest improvements for the idea's pitch strategy",
    "Conduct competitive analysis and market positioning",
    "Synthesize all gathered information and generate final evaluation report"
]

# Step callback function
def step_callback(job_id, step_output):
    if isinstance(step_output, AgentFinish):
        status = "completed"
        result = step_output.return_values.get('output', '')
    else:
        status = "in_progress"
        result = str(step_output)

    current_step = evaluation_jobs[job_id].get('current_step', 0)
    current_agent = get_agent_for_step(current_step)

    evaluation_jobs[job_id]['current_step'] = current_step
    evaluation_jobs[job_id]['current_agent'] = current_agent
    evaluation_jobs[job_id]['tasks'][current_step - 1]['status'] = status
    evaluation_jobs[job_id]['tasks'][current_step - 1]['result'] = result

    socketio.emit('evaluation_update', {
        'job_id': job_id,
        'status': status,
        'result': result,
        'current_step': current_step,
        'total_steps': len(workflow),
        'step_description': workflow[current_step - 1],
        'current_agent': current_agent
    })

# Create tasks
def create_tasks(job_id):
    return [
        Task(
            description="Gather and analyze data on recent YC accepted applications",
            agent=alex_dataminer,
            expected_output="JSON document containing detailed information on recent YC accepted startups, including industry, funding, team composition, and key metrics",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Identify current YC selection criteria and preferences",
            agent=samantha_ycinsider,
            expected_output="Report outlining YC's current selection criteria, preferences, and any recent shifts in investment focus",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Analyze current market trends and emerging technologies",
            agent=marcus_trendspotter,
            expected_output="List of top market trends and emerging technologies relevant to YC's interests, with supporting data",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Evaluate the given idea against YC criteria and market trends",
            agent=ryan_companalyst,
            expected_output="Initial assessment report comparing the given idea to YC criteria and current market trends",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Assess technical feasibility and innovation of the idea",
            agent=emily_techevaluator,
            expected_output="Technical evaluation report detailing the idea's feasibility, innovativeness, and potential technical challenges",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Analyze and suggest improvements for the idea's pitch strategy",
            agent=olivia_pitchperfector,
            expected_output="Pitch analysis report with specific recommendations for improvement",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Conduct competitive analysis and market positioning",
            agent=ryan_companalyst,
            expected_output="Competitive landscape report and suggested market positioning strategy",
            callback=lambda output: step_callback(job_id, output)
        ),
        Task(
            description="Synthesize all gathered information and generate final evaluation report",
            agent=david_synthesisguru,
            expected_output="Comprehensive evaluation report assessing the idea's chances of YC acceptance, including strengths, weaknesses, and recommendations",
            callback=lambda output: step_callback(job_id, output)
        )
    ]

def get_agent_for_step(step):
    step_agent_map = {
        1: "Alex DataMiner",
        2: "Samantha YCInsider",
        3: "Marcus TrendSpotter",
        4: "Ryan CompAnalyst",
        5: "Emily TechEvaluator",
        6: "Olivia PitchPerfector",
        7: "Ryan CompAnalyst",
        8: "David SynthesisGuru"
    }
    return step_agent_map.get(step, "Unknown Agent")

def run_task(job_id, task_index):
    task = evaluation_jobs[job_id]['tasks'][task_index]
    crew = Crew(
        agents=[alex_dataminer, samantha_ycinsider, marcus_trendspotter, olivia_pitchperfector,
                ryan_companalyst, emily_techevaluator, david_synthesisguru],
        tasks=[task],
        process=Process.sequential
    )
    result = crew.kickoff()
    evaluation_jobs[job_id]['current_step'] = task_index + 1
    evaluation_jobs[job_id]['tasks'][task_index]['status'] = 'completed'
    evaluation_jobs[job_id]['tasks'][task_index]['result'] = result
    return result

@app.route('/')
def serve_index():
    return send_from_directory('.', 'index.html')

@app.route('/api/evaluate', methods=['POST'])
def start_evaluation():
    idea = request.json['idea']
    job_id = str(uuid.uuid4())
    tasks = create_tasks(job_id)
    evaluation_jobs[job_id] = {
        'status': 'pending',
        'idea': idea,
        'current_step': 0,
        'tasks': [{'status': 'pending', 'result': None} for _ in tasks]
    }
    return jsonify({'job_id': job_id}), 202

@app.route('/api/evaluate/<job_id>/status', methods=['GET'])
def get_evaluation_status(job_id):
    job = evaluation_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    return jsonify({
        'status': job['status'],
        'current_step': job.get('current_step', 0),
        'total_steps': len(workflow),
        'current_agent': job.get('current_agent'),
        'tasks': job['tasks']
    })

@app.route('/api/evaluate/<job_id>/task/<int:task_index>', methods=['POST'])
def execute_task(job_id, task_index):
    job = evaluation_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    if task_index < 0 or task_index >= len(job['tasks']):
        return jsonify({'error': 'Invalid task index'}), 400
    if job['tasks'][task_index]['status'] == 'completed':
        return jsonify({'error': 'Task already completed'}), 400

    Thread(target=run_task, args=(job_id, task_index)).start()
    return jsonify({'message': 'Task execution started'}), 202

@app.route('/api/evaluate/<job_id>/results', methods=['GET'])
def get_evaluation_results(job_id):
    job = evaluation_jobs.get(job_id)
    if not job:
        return jsonify({'error': 'Job not found'}), 404
    return jsonify({'results': job['tasks']})

@app.route('/api/agents', methods=['GET'])
def get_agents():
    return jsonify(agents)

@app.route('/api/workflow', methods=['GET'])
def get_workflow():
    return jsonify(workflow)

if __name__ == '__main__':
    socketio.run(app, host='localhost', port=7457, debug=True)
</SERVER_PYTHON_CODE>

This implementation adapts the original code to our specific YC application evaluation task. Here are the key changes:

1. Updated the agents to match our design (Alex DataMiner, Samantha YCInsider, etc.).
2. Modified the workflow steps to align with our task design.
3. Updated the `create_tasks` function to create tasks based on our workflow.
4. Changed the `get_agent_for_step` function to map steps to our new agents.
5. Updated the API endpoints to use "evaluate" instead of "research" to better reflect the task.
6. Modified the input to accept an "idea" instead of a "topic".
7. Changed the port to 7457 as requested.

The core functionality remains the same:
- Users can submit an idea for evaluation.
- The system will process the idea through a series of tasks, each handled by a specialized agent.
- Users can check the status of the evaluation and retrieve results.
- The system provides real-time updates via WebSocket.

This implementation should provide a solid foundation for evaluating startup ideas against YC's criteria and current trends. You may need to further customize the agents' behaviors and the specific details of each task to fully match your requirements.
=== 6: user ===
Generate "index.html" that connect to the server.

Frontend should have UX component to refect each agents, the overall workflow, the execution status of the workflow and results.   

=== 7: assistant ===
Certainly! I'll create an "index.html" file that connects to the server and provides a user interface to reflect each agent, the overall workflow, execution status, and results. Here's the HTML file with embedded JavaScript and CSS:

<INDEX_HTML_CODE>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YC Application Evaluator</title>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2 {
            color: #2c3e50;
        }
        #idea-form {
            margin-bottom: 20px;
        }
        #idea-input {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
        }
        button:hover {
            background-color: #2980b9;
        }
        #status, #results {
            margin-top: 20px;
        }
        .agent {
            background-color: #ecf0f1;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .agent h3 {
            margin-top: 0;
        }
        .workflow-step {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .step-number {
            background-color: #3498db;
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-right: 10px;
        }
        .step-description {
            flex-grow: 1;
        }
        .step-status {
            width: 100px;
            text-align: right;
        }
        .completed {
            color: #27ae60;
        }
        .in-progress {
            color: #f39c12;
        }
        .pending {
            color: #95a5a6;
        }
    </style>
</head>
<body>
    <h1>YC Application Evaluator</h1>
    
    <div id="idea-form">
        <h2>Submit Your Idea</h2>
        <textarea id="idea-input" rows="4" placeholder="Describe your startup idea here..."></textarea>
        <button onclick="submitIdea()">Evaluate Idea</button>
    </div>

    <div id="agents">
        <h2>Evaluation Agents</h2>
        <!-- Agents will be dynamically added here -->
    </div>

    <div id="workflow">
        <h2>Evaluation Workflow</h2>
        <!-- Workflow steps will be dynamically added here -->
    </div>

    <div id="status">
        <h2>Evaluation Status</h2>
        <p id="current-status">No evaluation in progress</p>
    </div>

    <div id="results">
        <h2>Evaluation Results</h2>
        <div id="result-content"></div>
    </div>

    <script>
        const socket = io('http://localhost:7457');
        let currentJobId = null;

        socket.on('evaluation_update', (data) => {
            updateStatus(data);
            updateWorkflowStatus(data);
        });

        function submitIdea() {
            const idea = document.getElementById('idea-input').value;
            if (!idea) {
                alert('Please enter your idea before submitting.');
                return;
            }

            fetch('http://localhost:7457/api/evaluate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ idea: idea }),
            })
            .then(response => response.json())
            .then(data => {
                currentJobId = data.job_id;
                document.getElementById('current-status').innerText = 'Evaluation started. Job ID: ' + currentJobId;
                startEvaluation();
            })
            .catch(error => console.error('Error:', error));
        }

        function startEvaluation() {
            executeNextTask(0);
        }

        function executeNextTask(taskIndex) {
            fetch(`http://localhost:7457/api/evaluate/${currentJobId}/task/${taskIndex}`, {
                method: 'POST',
            })
            .then(response => response.json())
            .then(data => console.log(data))
            .catch(error => console.error('Error:', error));
        }

        function updateStatus(data) {
            document.getElementById('current-status').innerText = `Step ${data.current_step} of ${data.total_steps}: ${data.step_description}`;
            document.getElementById('result-content').innerHTML += `<p><strong>${data.current_agent}:</strong> ${data.result}</p>`;

            if (data.status === 'completed' && data.current_step < data.total_steps) {
                executeNextTask(data.current_step);
            } else if (data.current_step === data.total_steps) {
                document.getElementById('current-status').innerText = 'Evaluation completed!';
            }
        }

        function updateWorkflowStatus(data) {
            const steps = document.querySelectorAll('.workflow-step');
            steps.forEach((step, index) => {
                const statusElement = step.querySelector('.step-status');
                if (index < data.current_step) {
                    statusElement.innerText = 'Completed';
                    statusElement.className = 'step-status completed';
                } else if (index === data.current_step - 1) {
                    statusElement.innerText = 'In Progress';
                    statusElement.className = 'step-status in-progress';
                } else {
                    statusElement.innerText = 'Pending';
                    statusElement.className = 'step-status pending';
                }
            });
        }

        // Fetch and display agents
        fetch('http://localhost:7457/api/agents')
            .then(response => response.json())
            .then(agents => {
                const agentsContainer = document.getElementById('agents');
                agents.forEach(agent => {
                    const agentElement = document.createElement('div');
                    agentElement.className = 'agent';
                    agentElement.innerHTML = `
                        <h3>${agent.name}</h3>
                        <p><strong>Role:</strong> ${agent.role}</p>
                    `;
                    agentsContainer.appendChild(agentElement);
                });
            })
            .catch(error => console.error('Error fetching agents:', error));

        // Fetch and display workflow
        fetch('http://localhost:7457/api/workflow')
            .then(response => response.json())
            .then(workflow => {
                const workflowContainer = document.getElementById('workflow');
                workflow.forEach((step, index) => {
                    const stepElement = document.createElement('div');
                    stepElement.className = 'workflow-step';
                    stepElement.innerHTML = `
                        <div class="step-number">${index + 1}</div>
                        <div class="step-description">${step}</div>
                        <div class="step-status pending">Pending</div>
                    `;
                    workflowContainer.appendChild(stepElement);
                });
            })
            .catch(error => console.error('Error fetching workflow:', error));
    </script>
</body>
</html>
</INDEX_HTML_CODE>

This HTML file creates a user interface that connects to the server and provides the following features:

1. A form to submit the startup idea for evaluation.
2. A section displaying all the evaluation agents.
3. A visual representation of the evaluation workflow.
4. Real-time status updates of the evaluation process.
5. Display of evaluation results as they come in.

The JavaScript code handles the following:

- Connecting to the WebSocket server for real-time updates.
- Submitting the idea to the server.
- Executing tasks sequentially.
- Updating the UI with the current status and results.
- Fetching and displaying the list of agents and workflow steps.

The CSS styles provide a clean and organized layout for the interface, with color-coding for different statuses (completed, in-progress, pending).

To use this, save the code as "index.html" in the same directory as your server script. Make sure your server is running on `localhost:7457`, and then open the HTML file in a web browser. You should be able to submit an idea, see the agents and workflow, and watch the evaluation process in real-time.
=== 8: user ===
Stylize and make "index.html" beatuful, look production-ready, by using pure CSS website framework "Tailwind CSS".

=== Reply 0 ===
Certainly! I'll redesign the "index.html" file using Tailwind CSS to make it more beautiful and production-ready. Tailwind CSS is a utility-first CSS framework that allows for rapid UI development. Here's the updated version of the HTML file:

<INDEX_HTML_CODE>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YC Application Evaluator</title>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-4xl font-bold text-gray-800 mb-8">YC Application Evaluator</h1>
        
        <div class="bg-white rounded-lg shadow-md p-6 mb-8">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Submit Your Idea</h2>
            <textarea id="idea-input" rows="4" class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Describe your startup idea here..."></textarea>
            <button onclick="submitIdea()" class="mt-4 bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition duration-300 ease-in-out">Evaluate Idea</button>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-2xl font-semibold text-gray-700 mb-4">Evaluation Agents</h2>
                <div id="agents" class="space-y-4">
                    <!-- Agents will be dynamically added here -->
                </div>
            </div>

            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-2xl font-semibold text-gray-700 mb-4">Evaluation Workflow</h2>
                <div id="workflow" class="space-y-3">
                    <!-- Workflow steps will be dynamically added here -->
                </div>
            </div>
        </div>

        <div class="mt-8 bg-white rounded-lg shadow-md p-6">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Evaluation Status</h2>
            <p id="current-status" class="text-lg text-gray-600">No evaluation in progress</p>
        </div>

        <div class="mt-8 bg-white rounded-lg shadow-md p-6">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Evaluation Results</h2>
            <div id="result-content" class="space-y-3">
                <!-- Results will be dynamically added here -->
            </div>
        </div>
    </div>

    <script>
        const socket = io('http://localhost:7457');
        let currentJobId = null;

        socket.on('evaluation_update', (data) => {
            updateStatus(data);
            updateWorkflowStatus(data);
        });

        function submitIdea() {
            const idea = document.getElementById('idea-input').value;
            if (!idea) {
                alert('Please enter your idea before submitting.');
                return;
            }

            fetch('http://localhost:7457/api/evaluate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ idea: idea }),
            })
            .then(response => response.json())
            .then(data => {
                currentJobId = data.job_id;
                document.getElementById('current-status').innerText = 'Evaluation started. Job ID: ' + currentJobId;
                startEvaluation();
            })
            .catch(error => console.error('Error:', error));
        }

        function startEvaluation() {
            executeNextTask(0);
        }

        function executeNextTask(taskIndex) {
            fetch(`http://localhost:7457/api/evaluate/${currentJobId}/task/${taskIndex}`, {
                method: 'POST',
            })
            .then(response => response.json())
            .then(data => console.log(data))
            .catch(error => console.error('Error:', error));
        }

        function updateStatus(data) {
            document.getElementById('current-status').innerText = `Step ${data.current_step} of ${data.total_steps}: ${data.step_description}`;
            document.getElementById('result-content').innerHTML += `
                <div class="bg-gray-100 p-4 rounded-md">
                    <p class="font-semibold text-gray-700">${data.current_agent}:</p>
                    <p class="text-gray-600 mt-2">${data.result}</p>
                </div>
            `;

            if (data.status === 'completed' && data.current_step < data.total_steps) {
                executeNextTask(data.current_step);
            } else if (data.current_step === data.total_steps) {
                document.getElementById('current-status').innerText = 'Evaluation completed!';
            }
        }

        function updateWorkflowStatus(data) {
            const steps = document.querySelectorAll('.workflow-step');
            steps.forEach((step, index) => {
                const statusElement = step.querySelector('.step-status');
                if (index < data.current_step) {
                    statusElement.innerText = 'Completed';
                    statusElement.className = 'step-status text-green-500 font-semibold';
                } else if (index === data.current_step - 1) {
                    statusElement.innerText = 'In Progress';
                    statusElement.className = 'step-status text-blue-500 font-semibold';
                } else {
                    statusElement.innerText = 'Pending';
                    statusElement.className = 'step-status text-gray-400';
                }
            });
        }

        // Fetch and display agents
        fetch('http://localhost:7457/api/agents')
            .then(response => response.json())
            .then(agents => {
                const agentsContainer = document.getElementById('agents');
                agents.forEach(agent => {
                    const agentElement = document.createElement('div');
                    agentElement.className = 'bg-gray-100 p-4 rounded-md';
                    agentElement.innerHTML = `
                        <h3 class="text-lg font-semibold text-gray-700">${agent.name}</h3>
                        <p class="text-gray-600 mt-1"><span class="font-medium">Role:</span> ${agent.role}</p>
                    `;
                    agentsContainer.appendChild(agentElement);
                });
            })
            .catch(error => console.error('Error fetching agents:', error));

        // Fetch and display workflow
        fetch('http://localhost:7457/api/workflow')
            .then(response => response.json())
            .then(workflow => {
                const workflowContainer = document.getElementById('workflow');
                workflow.forEach((step, index) => {
                    const stepElement = document.createElement('div');
                    stepElement.className = 'workflow-step flex items-center';
                    stepElement.innerHTML = `
                        <div class="flex-shrink-0 w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center mr-3">${index + 1}</div>
                        <div class="flex-grow">
                            <p class="text-gray-700">${step}</p>
                        </div>
                        <div class="step-status text-gray-400 ml-3">Pending</div>
                    `;
                    workflowContainer.appendChild(stepElement);
                });
            })
            .catch(error => console.error('Error fetching workflow:', error));
    </script>
</body>
</html>
</INDEX_HTML_CODE>

This updated version of the HTML file uses Tailwind CSS to create a more visually appealing and professional-looking interface. Here are the key changes and improvements:

1. Added Tailwind CSS via CDN for easy usage without setup.
2. Incorporated a clean, modern design with consistent spacing and typography.
3. Used a card-based layout for different sections (idea submission, agents, workflow, status, and results).
4. Improved the visual hierarchy with appropriate font sizes and weights.
5. Added subtle shadows and rounded corners for a more polished look.
6. Used a color scheme that's easy on the eyes and provides clear visual cues for different states (pending, in progress, completed).
7. Made the layout responsive, so it looks good on both desktop and mobile devices.
8. Improved the presentation of agents, workflow steps, and results with better formatting and background colors.

This design now looks more production-ready and provides a better user experience. The functionality remains the same as the previous version, but the presentation is significantly improved.

To use this, save the code as "index.html" in the same directory as your server script. Make sure your server is running on `localhost:7457`, and then open the HTML file in a web browser. You should see a much more polished and professional-looking interface for the YC Application Evaluator.